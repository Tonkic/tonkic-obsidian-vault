- 端口：
	- ES 9200
	- Kibana 5601
	- ElasticView 8090
# 分片（shard）的基本策略
1. 一个索引包含一个或多个分片。创建索引时，如果不指定主分片数，默认一个主分片。副本可以在索引创建之后修改数量，但是主分片的数量一旦确定不可修改；
2. 每个分片都是一个Lucene 实例，有完整的创建索引和处理请求的能力；
3. ES 会自动在nodes 上做分片均衡shard rebalance；
4. 一个doc不可能同时存在于多个主分片中，但是当每个主分片的副本数量不唯一时，可以同时存在于多个副本中。
5. 主分片和其副本分片不能同时存在于同一个节点上。
6. 完全相同的副本不能同时存在于同一个节点上。
```
PUT allocation-test
{
	"settings": {
		"number_of_shards": 3,
		"number_of_replicas": 1
	}
}
```
- 表示3个主分片，每个主分片一个副本
## 集群状态三种类型
- red
	- 有主分片没有分配
- yellow
	- 有副分片没有分配
- green
	- 主副分片都已经分配
索引数据
# . mappings(映射)是指索引的结构(字段)
![[../../pic/Pasted image 20241225222456.png]]
## 索引映射支持的字段类型包括
1，文本类型text（注意不是String）
2，数值类型（long,integer,float,double,short,byte）
3，日期类型date
4，关键字类型keyword
5，布尔类型boolean
6，经纬度类型geo_point
7，对象类型（JSON格式）
8，数组类型
9，二进制文件类型
### text类型和keyword类型区别
- text类型，默认==需要分词处理==；即text字符串不是原封不动直接索引入库和检索。需要分词、去除停用词等，即保留文本中的关键信息来存储和检索。
- keyword类型：用于保存不经过分析、处理的==原始文本==。当需要对文本字段进行精准。匹配查询时必须使用keyword类型。
#### 即想分词又想精确匹配时
给text类型字段添加一个fields参数，在fields中放一个不分词的keyword类型字段。
1. **match查询**：你希望能够根据产品名字中的某个关键词（比如 "iPhone" 或 "Max"）来查找产品。
2. **term查询**：你还希望能够精确地查询某个完整的产品名称（比如 "Apple iPhone 13 Pro Max"），而不是只查找关键词。

## 关于ignore_malformed
为某个字段指定ignore_malformed为true表示：即使该字段输入数据不匹配，不影响其他字段的输入
```json
{
  "name": "John Doe",
  "age": 30,
  "email": "john.doe@example.com"
}
```

如果 `age` 字段被设置为 `integer` 类型，但传入了一个无效值（如字符串 "twenty"）：

```json
{
  "name": "John Doe",
  "age": "twenty",  // 这里是无效值
  "email": "john.doe@example.com"
}
```
## 布尔查询支持两种上下文（Context）：
#### 1. **搜索上下文 (Query Context)**
- 在搜索上下文中，查询需要计算**相关度得分**
- **适用场景**：适合放置**带有文本分析的查询**，例如 `match`、`text` 等查询类型，这些查询会对文档内容进行分词分析。
#### 2. **过滤上下文 (Filter Context)**
- 在过滤上下文中，查询只判断**搜索条件是否与文档数据匹配**，不需要进行相关度计算。
- **适用场景**：适合放置**术语查询**（如 `term`、`terms`）等类型的查询，它们通常是精确匹配，无需相关度评分。
## 嵌套关系
#### 直接使用数组时会把数据展平
产生类似下面代码的效果:
"goods.goods_name": \["milk","juice"],
"goods.produce time":\["2020-10-04 00:00:00","2020-10-12 00:00:00"]
#### 使用nested定义嵌套关系解决
## 使用join定义父子关系
```
PUT /products
{
  "mappings": {
    "properties": {
      "category": {
        "type": "join",
        "relations": {
          "parent": "child"  
          // "parent" 是父文档，"child" 是子文档
        }
      },
      "name": {
        "type": "text"
      },
      "price": {
        "type": "float"
      }
      //category，name，price同级，在category中使用join定义父子
    }
  }
}
//插入父文档
POST /products/_doc/1
{
  "name": "Electronics",
  "category": "parent"  // 标识该文档为父文档
}
//插入子文档
POST /products/_doc/2
{
  "name": "Smartphone",
  "category": {
    "name": "child",
    "parent": "1"  // 父文档ID是1
  }
}
```
使用"has_parent"查询子文档"has_child"查询父文档