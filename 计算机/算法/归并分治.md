适用条件：
1）思考一个问题在大范围上的答案，是否等于，左部分的答案+右部分的答案+跨越左右产生的答案
2）计算“跨越左右产生的答案”时，如果加上左、右各自有序这个设定，会不会获得计算的便利性
3）如果以上两点都成立，那么该问题很可能被归并分治解决（话不说满，因为总有很毒的出题人）
4）求解答案的过程中只需要加入归并排序的过程即可，因为要让左、右各自有序，来获得计算的便利性
一些用归并分治解决的问题，往往也可以用线段树、树状数组等解法。时间复杂度也都是最优解，这些数据结构都会在【扩展】课程阶段讲到

其实就是在一边归并排序的同时解决问题
https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469
``` C++
#include <iostream>
#include <vector>
using namespace std;

vector<int> a;      
vector<int> helper; 

long Merge(int l, int m, int r) {
    int i = l, j = m + 1, k = l;
    long ans = 0;

    // 统计小和
    while (i <= m && j <= r) {
        if (a[i] <= a[j]) {
            ans += a[i] * (r - j + 1); 
            helper[k++] = a[i++];
        } else {
            helper[k++] = a[j++];
        }
    }

    // 处理剩余元素(排序)
    while (i <= m) {
        helper[k++] = a[i++];
    }
    while (j <= r) {
        helper[k++] = a[j++];
    }

    // 将 helper 数组中的内容复制回原数组
    for (i = l; i <= r; i++) {
        a[i] = helper[i];
    }

    return ans;
}

long SmallSum(int l, int r) {
    if (l == r) {
        return 0;
    }
    int mid = (l + r) / 2;
    return SmallSum(l, mid) + SmallSum(mid + 1, r) + Merge(l, mid, r);
}

int main() {
    int N;
    cin >> N;
    a.resize(N);      
    helper.resize(N); 
    for (int i = 0; i < N; i++) {
        cin >> a[i];
    }
    long ans = SmallSum(0, N - 1);
    cout << ans << endl;
    return 0;
}
```