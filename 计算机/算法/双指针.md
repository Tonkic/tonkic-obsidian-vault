判断链表是否有环，快慢指针一个一次走2一个一次走1，相遇了快指针回开头，快慢指针都是一次走1

接雨水 https://leetcode.cn/problems/trapping-rain-water/
```C++
int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) return 0;

        vector<int> left(n);
        vector<int> right(n);

        left[0] = height[0];
        for (int i = 1; i < n; i++) {
            left[i] = max(left[i - 1], height[i]);
        }

        right[n - 1] = height[n - 1];
        for (int j = n - 2; j >= 0; j--) {
            right[j] = max(right[j + 1], height[j]);
        }

        int ans = 0;
        for (int k = 1; k < n-1; k++) {
            int min_height = min(left[k], right[k]);
            ans += min_height - height[k];
        }

        return ans;
    }
    //可以通过左右指针往中间走得到双指针最优解，上述代码不是最优解
```
https://leetcode.cn/problems/boats-to-save-people/
```C++
int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(),people.end());
        int left = 0,right = people.size()-1;
        int ans = 0;
        while(left<=right){
            int sum = left == right ? people[left] : people[left] + people[right];
            if(sum>limit){
                right--;
                ans++;
            }
            if(sum<=limit){
                left++;
                right--;
                ans++;
            }
        }
        return ans;
    }
```