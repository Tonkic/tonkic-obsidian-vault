前缀树又叫字典树，英文名trie：
每个样本都从头节点开始根据前缀字符或者前缀数字建出来的一棵大树，就是前缀树
没有路就新建节点；已经有路了，就复用节点
前缀树的使用场景：需要根据前缀信息来查询的场景
前缀树的优点：根据前缀信息选择树上的分支，可以节省大量的时间
前缀树的缺点：比较浪费空间，和总字符数量有关，字符的种类有关
前缀树的定制：pass、end等信息

如果分支pass=0，可以把整条剪枝

```C++
//类实现
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Trie {
  private:
    struct TrieNode {
        int pass; // 经过该节点的次数
        int end;  // 以该节点结尾的单词数量
        vector<TrieNode*> next; // 子节点

        TrieNode() : pass(0), end(0), next(26, nullptr) {}
    };

    TrieNode* root; // 根节点

  public:
    Trie() {
        root = new TrieNode(); // 初始化根节点
    }

    // 插入单词
    void insert(const string& word) {
        TrieNode* node = root;
        for (char ch : word) {
            int index = ch - 'a';
            if (node->next[index] == nullptr) {
                node->next[index] = new TrieNode();
            }
            node = node->next[index];
            node->pass++;
        }
        node->end++;
    }

    // 删除单词
    void deleteWord(const string& word) {
        TrieNode* node = root;
        for (char ch : word) {
            int index = ch - 'a';
            node = node->next[index];
            node->pass--;
        }
        node->end--;
    }

    // 搜索单词
    bool search(const string& word) {
        TrieNode* node = root;
        for (char ch : word) {
            int index = ch - 'a';
            if (node->next[index] == nullptr || node->next[index]->pass == 0) {
                return false;
            }
            node = node->next[index];
        }
        return node->end > 0;
    }

    // 返回以pre为前缀的单词数量
    int prefixNumber(const string& pre) {
        TrieNode* node = root;
        for (char ch : pre) {
            int index = ch - 'a';
            if (node->next[index] == nullptr || node->next[index]->pass == 0) {
                return 0;
            }
            node = node->next[index];
        }
        return node->pass;
    }
};

int main() {
    Trie trie; // 创建 Trie 对象
    int m;
    cin >> m;
    while (m--) {
        int op;
        string word;
        cin >> op >> word;
        if (op == 1) {
            trie.insert(word);
        } else if (op == 2) {
            trie.deleteWord(word);
        } else if (op == 3) {
            cout << (trie.search(word) ? "YES" : "NO") << endl;
        } else if (op == 4) {
            cout << trie.prefixNumber(word) << endl;
        }
    }
    return 0;
}
```