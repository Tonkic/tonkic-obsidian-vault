---
tags:
  - 操作系统
---
# 操作系统的基本概念
# 操作系统发展历程
1. **手工操作阶段**：依赖人工操作计算机。
2. **批处理阶段**：
    - **单道批处理**：一次只能处理一个任务。
    - **多道批处理**：同时处理多个任务
    - 操作系统在此时诞生，支持在使用I/O时进行其他任务计算。
1. **分时操作系统**：
    - **时间片轮转**：为各个用户分配时间片，实现多任务并发。
    - **优点**：提供人机交互。
    - **缺点**：不能优先处理紧急任务。
2. **实时操作系统**：
    - **优先响应紧急任务**。
    - **分类**：
        - **硬实时系统**：必须严格按时完成任务。
        - **软实时系统**：能接受偶尔延迟，时间控制要求不那么严格。
# 程序运行环境
## 1.CPU 运行模式
通过PSW寄存器里面的值判断是 内核模式 还是 用户模式。
- 内核态-> 用户态
	- 一条修改PSW的特权指令
- 用户态-> 内核态
	- 中断引起，硬件自动完成
## 2.中断和异常的处理
[总线和输入，输出系统 \> 2.程序中断方式](../计算机组成原理/总线和输入，输出系统.md#2.程序中断方式)
## 3.系统调用
1. **用户应用发起调用**：用户程序通过库函数（如 C 语言中的 `write`）准备参数，write系统调用需要 3 个参数：
	- 文件描述符,标准输出文件描述符为 1 ；
	- 写入内容(缓冲区)地址；
	- 写入内容长度(字节数)；
	然后发出软中断（如 `int 0x80`）以请求内核服务。
2. **内核处理请求**：接收到中断后，内核切换到内核模式，执行相应的系统调用服务例程（如 `sys_write`），同时要将参数复制到内核态保证安全。
3. **返回结果**：系统调用完成后，结果被返回给用户应用，CPU 切换回用户模式。
4. 用户程序继续执行，如果是exit系统调用，会使用户程序终止
## 4.程序的链接与装入
## 链接
- **静态链接**：程序运行前完成链接，生成完整的可执行文件。
- **装入时动态链接**：在程序装入内存时边装入边链接。
- **运行时动态链接**：程序执行时按需链接目标模块，便于修改和共享。
## 装入
- **绝对装入**：程序直接指明物理地址，适用于单道程序环境。
- **可重定位装入**：装入时修改地址（静态重定位），无法在运行时移动。
- **动态运行时装入**：程序运行时动态调整地址，支持内存分配和程序段共享。
## 5.程序运行时的内存映像与地址空间
# 操作系统结构
内核就是运行在内核态的实现功能的程序
## 1. **大内核**：
- **定义**：所有操作系统功能都作为系统内核，运行在核心态。
- **优点**：高性能，模块间可直接调用。
- **缺点**：内核庞大且复杂，难以维护；某模块出错可能导致系统崩溃。
## 2. **微内核**
- **定义**：只保留最基本的功能在内核中。
- **优点**：内核小、易维护，可靠性高；模块出错不影响整个系统。
- **缺点**：性能低，频繁切换用户态/核心态，模块间只能通过消息传递通信。
## 3. **分层结构**
- **定义**：操作系统分为若干层，依次调用下层功能。
- **优点**：便于调试、验证，易于扩展和维护。
- **缺点**：层次划分困难，效率较差。
## 4. **模块化**
- **定义**：内核=主模块+可加载内核模块，主模块只负责核心功能支持动态加载新模块。
- **优点**：模块间逻辑清晰，支持动态加载，效率高。
- **缺点**：模块间接口不总是合理，依赖关系增加调试难度。
## 5. **外核**
- **定义**：内核负责基本功能，外核负责硬件资源分配和安全性保障。
- **优点**：直接分配硬件资源，提高效率。
- **缺点**：系统一致性差，复杂度增加。
# 操作系统引导
1. 激活CPU，boot将PC值设为bios程序的入口
2. 进行硬件自检
3. 读取硬盘，加载主引导记录（MBR）（硬盘的第一份扇区）
4. 扫描硬盘分区表
5. 加载活动分区的分区引导记录（PBR）（分区的第一份扇区）
6. 执行启动管理器
	- 启动管理器根据配置文件（如Windows中的BCD、XP中的boot.ini）显示操作系统选择菜单，用户选择后，控制权交给操作系统初始化程序。
7. 加载操作系统
# 虚拟机
虚拟化技术将一台物理计算机模拟为多台虚拟计算机
- **第一类虚拟机管理程序**（裸金属架构）直接控制硬件，虚拟机独立运行。
- **第二类虚拟机管理程序**（寄居架构）依赖宿主操作系统，虚拟机作为宿主操作系统的进程运行。---
tags:
  - 操作系统
---
# 进程与线程
## 1.进程与线程的基本概念
进程=PCB+程序段+数据段
线程是轻量级的进程，是处理机调度的最小单位
## 2.进程/线程的状态与转换
### 五状态
1. **就绪态 (Ready)**：进程已准备好运行，但因没有空闲CPU而暂时等待。
2. **运行态 (Running)**：进程正在占用CPU并执行。
3. **阻塞态 (Waiting/Blocked)**：进程因等待某个事件（如I/O操作）而暂时不能运行。
4. **创建态 (New)**：进程正在被创建，操作系统为其分配资源并初始化进程控制块 (PCB)。
5. **终止态 (Terminated)**：进程完成后，正从系统中撤销，操作系统回收资源并撤销PCB。
### 状态转换
1. **创建态到就绪态**：系统完成创建进程的所有工作
2. **就绪态到运行态**：进程被调度
3. **运行态到阻塞态**：进程主动使用*系统调用*请求系统资源或等待某个事件发生
4. **运行态到就绪态**：进程时间片到 或 被抢占
5. **阻塞态到就绪态**：当申请的资源被分配或等待的事件发生
6. **运行态到终止态**：进程完成运行或遇到不可修复的错误
## 3.线程的实现
### 线程库支持的线程
早期操作系统不支持线程，只能使用线程库（在用户态）在进程里模拟线程
### 内核支持的线程
有内核级的线程，用户线程对应内核进程有三种模型
- 一对一
- 多对一
- 多对多
## 4.进程与线程的组织与控制
### 组织
PCB中的state变量表示进程当前状态（阻塞还是就绪等）
1. **链接方式**：
- 按照进程状态（state）将PCB分为多个队列
- 操作系统持有指向各个队列的指针
2. **索引方式**：
 - 根据不同的进程状态建立多张索引表
 - 操作系统持有指向这些索引表的指针
### 控制
#### 原语与系统调用的区别
- ==系统调用是用户使用，让操作系统从用户态到内核态==
- ==原语是操作系统内核态下的一小段程序，操作系统通过原语调用硬件==
通过原语来实现进程状态转换（改变PCB的值和指针指向的队列），原语执行时必须一气呵成且不可中断
1. **创建原语**：进程的创建。
2. **撤销原语**：进程的终止。
3. **阻塞原语**：使进程进入阻塞状态。
4. **唤醒原语**：使阻塞的进程进入就绪状态。
5. **切换原语**：进行进程切换。
注：3.4.阻塞和唤醒成对使用，保证CPU“无缝衔接”
## 5.进程间通信
### 共享内存
- 系统为两个进程开辟一块共用的存储空间
- 两个进程互斥访问
- 可以由系统限制存储区的数据结构，也可以由两个进程自行协商
### 消息传递
进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
1. **直接通信方式**：消息带有接收方ID，发送到接收方的消息队列，接收原语根据ID查找消息。
2. **间接（信箱）通信方式**：消息先发送到一个中间体（信箱），由接收方从信箱中获取消息。
### 管道
管道通信是循环队列，内存中开辟一个固定大小的缓冲区（通常为一个页大小），使用文件描述符来实现，创建时会有一个fd0用来读，一个fd1用来写
1. **先进先出**：数据按顺序读写。
2. **半双工通信**：数据只能单向传输，使用两个管道可以实现双向通信。
3. **互斥访问**：进程访问管道时需互斥，写满时无法写，读空时无法读，写未满时无法读，读未空时无法写。
### 信号
使用类似singal/wait的操作
### CPU调度与上下文切换
## 1.调度的基本概念
1. **高级调度（作业调度）**：从外存的作业队列中挑选作业调入内存并创建进程，调出时撤销进程的PCB。每个作业只调入一次，调出一次。
2. **中级调度（内存调度）**：当内存不足时，将部分进程的数据调到外存，进程处于挂起状态。内存充足时，将挂起的进程重新调入内存。中级调度频率高于高级调度。
3. **低级调度（进程调度）**：从就绪队列中选取进程，分配处理器。进程调度是操作系统中的基本调度，频率很高，通常几十毫秒执行一次。
## 2.调度的目标
1. 响应速度尽可能快  
2. 进程处理的时间尽可能短  
3. 系统吞吐量极可能大(单位时间完成作业的数量)  
4. 资源（CPU）利用率尽可能高  
5. 对所有进程要公平  
6. 避免饥饿  
7. 避免死锁
### 指标
- 周转时间
    - 作业被提交给系统开始，到作业完成为止的这段时间间隔  
- 带权周转时间
    - 作业周转时间/作业实际运行的时间
- 等待时间
    - 进程、作业处于等待处理机状态时间之和。
- 响应时间
    - 从用户提交请求道首次产生相应所用的时间。
## 3.调度的实现
### 调度器/调度程序(scheduler)
操作系统中的组件，作用：
- 分配CPU时间
- 进程/线程状态切换
- 调度CPU或IO设备等其他资源
- 保证系统性能和调度公平
### 调度的时机与调度方式(抢占式/非抢占式)
#### 调度的时机
- 主动放弃
    - 进程正常终止
    - 运行过程中发生异常而终止
    - 主动阻塞(如 等待I/O)
- 被动放弃
    - 分给进程的时间片用完
    - 有更紧急的事情需要处理(如 I/O中断)
    - 有更高优先级的进程进入就绪队列
#### 不能调度的时机
- 在处理中断的过程中
- 进程在操作系统内核程序临界区中
    - 临界资源:一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
    - 临界区:访问临界资源的那段代码。
    - 普通临界区可以调度，内核临界区不行
- 原子操作过程中(原语)
#### 调度方式    
- 非剥夺调度方式(非抢占式)
    - 只能由当前运行的进程主动放弃CPU
- 剥夺调度方式(抢占式)
    - 可由操作系统剥夺当前进程的CPU使用权
### 闲逛进程
- 没有其他就绪进程时运行的进程
- 优先级最低
- 可以是0地址指令，占用完整的指令周期（周期末检查中断）
- 能耗低
### 内核级线程与用户级线程调度
1. **用户级线程：**
    - 线程管理在用户空间，由线程库提供。
    - 操作系统仅看到进程，无法直接调度线程。
    - 只能在单核上运行，无法实现并行加速。
    - 线程阻塞时，整个进程阻塞，效率低。
    - 可以定制调度算法，灵活性高。
    - 线程切换不涉及内核，开销小。
2. **内核级线程：**
    - 线程管理在内核空间，由操作系统调度。
    - 操作系统能够看到线程，可在多个CPU核心上并行调度。
    - 线程阻塞时，其他线程不受影响，效率高。
    - 切换线程时需要进入内核，开销较大。
    - 用来记录系统里所有线程的线程表有限，扩展性差。
## 4.CPU 调度算法
1. **先来先服务（FCFS）**：
    - 按照进程到达的顺序进行调度。
    - 优点：算法简单。
    - 缺点：对长作业有利，不利于短作业，且效率较低。
2. **短作业优先（SJF）**：
    - 优先调度要求服务时间最短的进程。
    - 分类：抢占式和非抢占式。
    - 优点：平均等待时间最少，但不可预知所有进程的服务时间。
3. **高响应比优先（HRRN）**：
    - 综合考虑进程的等待时间和服务时间，选择响应比最高的进程进行调度。
    - 响应比 = (等待时间 + 服务时间) / 服务时间。
4. **时间片轮转（RR）**：
    - 每个进程轮流获得一个时间片，时间片结束后，如果进程未完成，则重新排队。
    - 优点：公平，但时间片大小对性能有影响。
    - 时间片过大会退化为FCFS，过小则频繁切换进程，影响效率。
5. **优先级调度**：
    - 按优先级高低选择进程。
    - 分类：抢占式和非抢占式，静态和动态优先级。
    - 动态优先级：根据等待时间和I/O频率调整优先级。
6. **多级反馈队列调度**：
    - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
    - 只有第k级队列为空时，才会为k+1 级队头的进程分配时间片
## 5.多处理机调度
1. **单队列多处理机调度（SQMS）**：
    - 所有任务放在一个队列中，简单易实现。
    - 存在扩展性差和性能受限问题，特别是在多CPU情况下。
    - 采用锁机制保证正常运行，但可能降低性能。
    - 引入亲和度机制，尽量让任务在同一CPU上运行，以减少缓存问题。
2. **多队列多处理机调度（MQMS）**：
    - 将任务分配到多个队列，每个队列调度不同的任务。
    - 存在负载不均衡问题，可能导致某些CPU空闲（队列空），而其他CPU负载过重（队列满）。
    - 采用 **工作窃取（Work Stealing）** 策略：低负载（空）队列从高负载（满）队列窃取任务，确保负载均衡。
## 6.上下文及其切换机制
上下文就是寄存器和程序计数器等信息，切换就是把上一个的保存起来，引入下一个的
1. **进程上下文切换**：
    - 发生在不同进程之间的切换。
    - 时机：时间片耗尽、资源不足、主动挂起、优先级更高的进程、硬件中断等。
    - 切换需要保存和恢复进程的全部资源，如虚拟内存、寄存器等。
2. **线程上下文切换**：
    - 发生在同一进程内的线程切换。
    - 两种情况：
        - **同进程内的线程切换**：共享资源，只需保存和恢复线程私有数据、寄存器等。
        - **不同进程的线程切换**：类似进程上下文切换，需要保存和恢复更多资源。
    - 相较于进程切换，线程切换开销更小。
3. **中断上下文切换**：
    - 发生在中断处理时，CPU被中断，转而执行中断处理程序。
    - 只需保存和恢复内核态资源，如寄存器、内核堆栈等，不涉及用户态的资源。
# 同步与互斥
## 1.同步与互斥的基本概念
## 2.基本的实现方法
### 软件方法
#### 单标志法
- **原理**：两个进程在访问完临界区后，将使用权限转交给另一个进程。进入临界区的权限仅能由其他进程赋予。
- **逻辑**：体现“谦让”原则。
- **问题**：违背“空闲让进”原则。
#### 双标志先检查
- **原理**：使用布尔型数组`flag[]`标记各进程进入临界区的意愿。一个进程进入前检查其他进程是否有意，若没有进程想要进入才设置自己的`flag[i]`为true。
- **逻辑**：表达进入意愿。
- **问题**：违背“忙则等待”原则。检查和上锁的过程不是一气呵成，进程同时进入临界区
#### 双标志后检查
- **原理**：先设置状态（上锁）再进行检查（其他进程意愿）
- **问题**：违背“空闲让进”和“有限等待”原则，可能导致进程长期无法访问临界资源，产生“饥饿”。
#### Peterson算法
- **原理**：结合单标志法与双标志法的思想，当两个进程争抢临界区时，采用谦让策略。
- **步骤**：
    1. 设置自己的`flag[]`以主动争取。
    2. 设置对方的`turn[]`以主动谦让。
    3. flag和trun都是对方的值时等待
- **优点**：遵循“空闲让进”、“忙则等待”和“有限等待”原则。
- **问题**：不满足“让权等待”原则。
```C
Pi:
flag[i] = ture; turn = j;
while (flag[j] && turn == j);//轮到对方且对方想进入就等待
critical section;// 访问临界区
flag[i] = false;
remainder section;// 剩余区
 
Pj:
flag[j] = true; turn = i;
while (flag[i] && turn == i);
critical sectionl// 访问临界区
flag[j] = false;
remainder section;// 剩余区
```
### 硬件方法
#### 中断屏蔽方法
- **原理**：利用“开/关中断指令”实现互斥。
- **优点**：简单且高效。
- **缺点**：只适用于操作系统内核进程，不适用于多处理机和用户进程。
#### TestAndSet
- **原理**：整个操作不允许中断，确保“上锁”与“检查”由硬件控制。
- **优点**：适用于多处理机环境，在逻辑上更安全。
- **问题**：不满足“让权等待”。
```C
//布尔型共享变量 lock 表示当前临界区是否被加锁
//true 表示已加锁，false 表示未加锁
bool TestAndset(bool *lock){
	bool old;
	old =*lock;//old用来存放lock 原来的值
	*lock =true;//无论之前是否已加锁，都将lock设为true
	return old;
}
//调用
while(TestAndset(&lock));//lock原来的值为false才退出循环
```
#### Swap指令
- **原理**：通过交换指令实现互斥。
- **问题**：不满足“让权等待”。
```C
//lock 表示当前临界区是否被加锁  
bool old = true;  
while(old == true){ 
//如果lock是true，卡在while循环
	Swap(&lock,&old);  
}
临界区代码段。  
lock = false;  
剩余区代码段.
```
## 3.锁
### 互斥锁
**定义**：进程进入临界区前需获得锁，退出时释放。使用 `acquire()` 获得锁，`release()` 释放锁。
### 自旋锁
- **特点**：忙等的互斥锁，采用 TSL、Swap 指令或单标志法实现。
- **优点**：无需上下文切换，适合多处理器且锁持有时间短的场景。
- **缺点**：忙等浪费 CPU 时间，不适合单处理机，且可能违反“让权等待”。
## 4.信号量
**整型信号量**（int）
- 使用整数变量表示资源数量。
- **问题**：不满足“让权等待”，会发生忙等。
**记录型信号量**
相比int信号量多了：
- 小于0时block进程
- 大于0时唤醒进程
## 5.条件变量
用于线程间的通信，通常与互斥锁一起使用，以避免忙等问题。条件变量本身不是锁，但可以使线程阻塞，等待另一个线程发送信号。
## 6.经典同步问题
信号量定义写法：==semaphore mutex = 0;==
### 生产者-消费者问题
- `empty`：表示空余空间的信号量，缓冲区未满时大于0。
- `full`：表示已有产品的信号量，缓冲区不为空时大于0。
- `mutex`：互斥锁，确保缓冲区在访问时的互斥性。
```C
empty = BUFFER_SIZE;  // 缓冲区初始为空
full = 0;             // 缓冲区初始没有产品
mutex = 1;            // 互斥锁初始化为可用
// 生产者线程
void *producer(void *arg) {
    while (1) {
        // 生产产品
        P(empty);  // 等待空余空间
        P(mutex);  // 加锁，进入临界区
        // 放入产品到缓冲区
        V(mutex);  // 解锁，退出临界区
        V(full);   // 增加已有产品的数量
    }
}
// 消费者线程
void *consumer(void *arg) {
    while (1) {
        P(full);   // 等待缓冲区有产品
        P(mutex);  // 加锁，进入临界区
        // 从缓冲区取出产品
        V(mutex);  // 解锁，退出临界区
        V(empty);  // 增加空余空间的数量
    }
}
```
### 读者-写者问题
- **读者**：可以同时读取数据，但不能与写者同时操作。
- **写者**：在写操作进行时，其他任何读者和写者都不能访问数据。
#### 读优先
```C
mutex = 1;        // 互斥锁，保证互斥访问count
count = 0;    // 当前正在读的读者数
rw = 1;     // 读锁，控制读者间同步
// 读者线程
void *reader(void *arg) {
    while(1){
	    P(mutex);
	    if(count==0)P(rw); //第一个读者负责加锁
	    count++;
	    V(mutex);
	    // 读文件；
	    P(mutex);
	    count--;
	    if(count==0)V(rw); //最后一个读者负责解锁
	    V(mutex);
    }
}
// 写者线程
void *writer(void *arg) {
    P(rw);   // 写者等待，直到没有读者或其他写者
    // 执行写操作
    V(rw);   // 写完后释放写锁
}
```
#### 写优先
```C
mutex = 1;        // 互斥锁，保证互斥访问count
count = 0;    // 当前正在读的读者数
rw = 1;     // 读锁，控制读者间同步
w = 1;    //实现写优先
// 读者线程
void *reader(void *arg) {
    while(1){
	    P(w);    //有写进程的时候，新的读进程会被卡在这
	    P(mutex);
	    if(count==0)P(rw); //第一个读者负责加锁
	    count++;
	    V(mutex);
	    V(w);
	    // 读文件；
	    P(mutex);
	    count--;
	    if(count==0)V(rw); //最后一个读者负责解锁
	    V(mutex);
    }
}
// 写者线程
void *writer(void *arg) {
    P(w);
    P(rw);   // 写者等待，直到没有读者或其他写者
    // 执行写操作
    V(rw);   // 写完后释放写锁
    V(w);
}
```
### 哲学家进餐问题
假设有5个哲学家围坐在圆桌旁，桌上有5根筷子
解决办法：
1. **限制最大同时进餐的哲学家数量**：最多允许4个哲学家同时进餐，确保至少一个哲学家可以同时拿到左右两只筷子。
2. **奇偶哲学家先后拿筷子**：奇数号哲学家先拿左边筷子，再拿右边；偶数号哲学家先拿右边筷子
```C
mutex = 1;           // 互斥锁，用于控制哲学家的访问
chopstick[5] = {1, 1, 1, 1, 1}; // 表示筷子的信号量，1表示可用，0表示被占用
// 哲学家线程
void *philosopher(void *arg) {
    int i = *((int*)arg); // 哲学家的编号
    while (1) {
        think();
        P(mutex); // 加锁，防止多个哲学家同时拿筷子
        if (i % 2 == 0) {
            // 偶数号哲学家：先拿右边筷子，再拿左边筷子
            P(chopstick[(i + 1) % 5]); // 拿右边筷子
            P(chopstick[i]);            // 拿左边筷子
        } else {
            // 奇数号哲学家：先拿左边筷子，再拿右边筷子
            P(chopstick[i]);            // 拿左边筷子
            P(chopstick[(i + 1) % 5]); // 拿右边筷子
        }
        V(mutex); // 解锁
        eat();
        V(chopstick[i]);            // 放下左边筷子
        V(chopstick[(i + 1) % 5]); // 放下右边筷子
    }
}
```
# 死锁
## 1.死锁的基本概念
等待的资源在另一个进程手里
### 不死锁需要的资源
- 系统内有n个进程，每个进程都需要R个资源，那么其能发生死锁的最大资源数为n*（R-1）。其无论如何不发生死锁的最小资源数为n*（R-1）+1。
### 死锁的四个必要条件：
1. **互斥条件**：
    - 即每个资源在任意时刻只能被一个进程占用。
2. **不剥夺条件**：
    - 一旦进程获得了某个资源，系统不会强行剥夺该资源，进程必须自己释放。
3. **请求和保持条件**：
    - 进程已经持有至少一个资源，但又请求其他已经被占用的资源，并且在得到所请求的资源之前不会释放当前的资源。
4. **循环等待条件**：
    - 存在一个进程等待链，链中的每个进程都持有着下一个进程所需要的资源。
## 2.死锁预防
破坏四个必要条件之一
1. **破坏互斥条件**：
    - **方法**：将只能互斥的资源改为共享资源，如使用 SPOOLing 技术（共享打印机）。
    - **局限性**：并非所有资源都能改为共享，某些资源（如内存、文件锁）必须保持互斥。
2. **破坏不剥夺条件**：
    - **方法**：当进程无法获得资源时，立即释放已持有的资源。
    - **局限性**：可能导致饥饿（长期得不到资源），并需要考虑进程的优先级。
3. **破坏请求和保持条件**：
    - **方法**：采用静态分配策略，进程在启动前一次性申请所有所需资源。
    - **局限性**：资源利用率低，且可能导致进程饥饿。
4. **破坏循环等待条件**：
    - **方法**：使用顺序资源分配法，规定进程必须按资源编号递增顺序请求资源。
    - **局限性**：增加设备时需要重新编号，可能导致资源浪费，且不方便编程和资源申请。
## 3.死锁避免
1. **安全状态与安全序列**：
    - 系统处于安全状态时，存在至少一个进程执行的顺序（安全序列），所有进程都能顺利完成。
    - 如果找不到安全序列，系统进入不安全状态，可能发生死锁。
2. **银行家算法**：
    - 在进程请求资源时，预判此次分配是否会导致不安全状态。
    - 如果会导致不安全，系统暂不分配资源，进程进入等待状态，直到资源分配不会引发死锁。
## 4.死锁检测和解除
1. **死锁检测**：
    - **资源分配图**：包括进程节点和资源节点，边表示进程的资源请求和分配。
		- 进程结点（圆圈）:对应一个进程
		- 资源结点（矩形）:对应一类资源，一类资源可能有多个
		- 矩形中的圆点，一个圆点代表一个资源
    - **检测算法**：通过查找不阻塞且非孤立的进程，逐步消去资源分配图中的进程和边，若能完全简化图，系统是安全的，否则为死锁状态。
2. **死锁解除**：
    - **资源剥夺法**：挂起死锁进程并抢占其资源。
    - **撤销进程法**：强制撤销部分或全部死锁进程，代价高。
    - **进程回退法**：让死锁进程回退到安全状态，需要记录历史状态。
![../../pic/Pasted image 20241210162501.png](../../pic/Pasted%20image%2020241210162501.png)---
tags:
  - 操作系统
---
# 内存管理基础
## 1.内存管理的基本概念
### 逻辑地址空间与物理地址空间
不同进程可有相同的逻辑地址，因为逻辑地址可以映射到不同的物理内存位置
### 地址变换
- 会在系统中设置一个 页表寄存器(PTR)，存放 页表在内存中的起始地址F和页表长度M,
- 通过M来判断页号是否>=页表项数量，大于等于的时候触发越界中断，因为页表从0开始
- 进程未执行时，页表的始址 和 页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核才会把他们放在页表寄存器中。
 ![考研/操作系统/pic/Pasted image 20241210164507.png](../../pic/Pasted%20image%2020241210164507.png)
### 内存共享
两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存
### 内存保护
- 保证各进程在各自存储空间内运行，互不干扰
    - 操作系统的任务，处于安全性和效率，必须有硬件实现。
    - 两种方式
        - 设置上下限寄存器
        - 利用重定位寄存器、界地址寄存器进行判断
### 内存分配与回收
#### 连续分配管理方式
- 单一连续分配
- 固定分区分配
- 动态分区分配
#### 非连续分配管理方式
- 分页
- 分段
- 段页式
## 2.连续分配管理方式
### 单一连续分配
- 只支持单道程序，内存分为系统区和用户区，用户程序放在用户区，同一时刻只有一道用户程序
### 固定分区分配
- 将整个用户空间划分为若干个固定大小的分区
### 动态分区分配
#### 如何记录空闲内存
##### **空闲分区表**
- 每个空闲分区都对应一个表项，包含分区号、分区大小、分区起始地址等信息。
##### **空闲分区链**
- 每个分区的起始部分和末尾部分设置前向指针和后向指针，起始部分还可以记录分区的大小等信息，形成双向链表。
##### 基于顺序搜索的分区分配
- 首次适应算法（First FIt）
	- 每次都从低地址开始查找，找到第一个能满足大小的空闲分区
- 最佳适应算法（Best Fit）
	- 空闲分区按容量递增次序链接，优先使用更小的空闲区
	- 会产生很多很小的，难以利用的内存快，会产生很多的外部碎片
- 最坏适应算法(Worst Fit)\ 最大适应算法(Largest Fit)
	- 优先使用更大的空闲区，减少小外部碎片的产生
	- 大进程无内存可用
- 临近适应算法（Next Fit）
	- 首次适应算法的改进，从上次查找结束的位置开始检索，以减低前面算法每次都从最前面开始查找的开销
##### 基于索引搜索的分区分配
- 快速适应算法（分类搜索法）
![考研/操作系统/pic/Pasted image 20241210170401.png](../../pic/Pasted%20image%2020241210170401.png)
- 伙伴系统
	- 无论已分配分区或空闲分区，其大小均为 2 的 k 次幂(k 为整数，1 ≤ k ≤ m)。将这些空闲分区按分区的大小进行分类，对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。
	- 从小到大找适合的空间(2^i-1 < n ≤ 2^i)，找得到就用，*找不到就把上一级的拆成两块*，自己用一块，另一块空闲
![考研/操作系统/pic/Pasted image 20241210170507.png](../../pic/Pasted%20image%2020241210170507.png)
- Hash 算法
	- 在可利用空闲区表中建立哈希函数
## 3.页式管理
1. **分页存储**
    - **物理上**：内存被划分为大小相等的页框。
    - **逻辑上**：进程的地址空间被分为相同大小的页面。
2. **页表**
    - 进程与内存的对应表。每个页表项指示一个页面在物理内存中的位置(虚页号指向页框号)
    - 页号是隐含的，不占空间
3. **地址转换**
    - **页号**：逻辑地址除以页面大小。
    - **页内偏移量**：逻辑地址对页面大小取模。
    - 对于2的幂次方大小的页面，页号由高位决定，页内偏移量由低位决定。
4. **基本地址变换机构** 
  - [内存管理 \> 地址变换](../操作系统/内存管理.md#地址变换)
5. **块表地址变换机构**
	- 快表需要存页号用来标识
![考研/操作系统/pic/Pasted image 20241210171121.png](../../pic/Pasted%20image%2020241210171121.png)
6. **两级页表**
    - 逻辑地址变为一级页号+二级页号+页内偏移量
7. **虚拟存储技术与缺页中断**
    - 页表项增加标志位，指示页面是否在内存中。如果页面不在内存中，会发生缺页中断并加载页面。
8. **多级页表**
    - 多级页表机制可解决页表过大和内存不连续的问题，保证每级页表的大小不超过一个页面。
## 4.段式管理
![考研/操作系统/pic/Pasted image 20241210171544.png](../../pic/Pasted%20image%2020241210171544.png)
## 5.段页式管理
先分段，段内分页
逻辑地址段号+页号+页内偏移量
# 虚拟内存管理
## 1.虚拟内存的基本概念
- 基于局部性原理，将程序常用部分加载到内存，其他部分存储在外存。
- **最大容量**
    - 由CPU地址长度决定。若CPU字长能表示的内存大于外存，虚拟内存容量为内存与外存之和。若外存容量远大于CPU字长，虚拟内存容量受CPU字长限制。
## 2.请求页式管理
- 页表除了记录页面的物理地址外，还增加了以下四个字段：
    - **状态位**：表示该页面是否已调入内存，未调入时会触发缺页中断。
    - **访问字段**：记录页面的访问情况，可以用于置换算法选择哪些页面需要被换出。
    - **修改位**：表示页面是否被修改，若未修改则不需要写回外存。
    - **外存地址**：表示页面在外存中的存放位置。
## 3.页框分配与回收
1. **驻留集**：进程分配的物理块集合，大小通常小于进程总大小。
    - **过小**：频繁缺页，性能下降。
    - **过大**：（整个系统）多道程序并发度降低，资源利用率下降。
2. **页面分配与置换策略**：
    - **分配方式**：
        - **固定分配**：驻留集大小不变。
        - **可变分配**：驻留集大小可动态变化，根据需要调整。
    - **置换方式**：
        - **局部置换**：仅替换进程自己的页面。
        - **全局置换**：可替换其他进程的页面或空闲物理块。
	- 固定分配不能搭配全局替换
3. **调入页面的时机**：
    - **预调页策略**：运行前预测可能访问的页面，成功率低。
    - **请求调页策略**：运行时缺页触发调入，单次调入一页，IO开销较大。
4. **页面调入来源**：
   对换区：外存中速度较快的区域，用于与内存交换数据，连续分配
   文件区：外存中速度较慢的区域，离散分配（页式/段式）
    - **对换区足够**：页面在内存与对换区间调入调出。
    - **对换区不足**：未修改页面直接从文件区调入，修改页面需写回对换区。
    - **UNIX方式**：未使用页面从文件区调入，使用后换出写回对换区。
6. **抖动现象**：  
    页面频繁被换入换出，导致性能严重下降。通常是进程频繁访问的页面数目超出可用物理块数。
7. **工作集**：  
    进程在一段时间内实际访问的页面集合。驻留集大小应大于或等于工作集大小，以避免频繁缺页。
## 4.页置换算法
- **最佳置换算法（OPT）**：选择未来最久不被使用的页面，但此算法无法实现。
- **先进先出算法（FIFO）**：淘汰最早进入内存的页面，但可能导致**Belady异常**，缺页率反而增大。
- **最近最久未使用算法（LRU）**：淘汰最久未使用的页面，通常根据访问字段进行选择。
- **时钟置换算法**：
	- 设置访问位，并将内存页面链接成循环队列。当页面被访问时，访问位设为1。
	- 淘汰页面时，检查页面的访问位：若为0，则换出该页；若为1，将访问位设为0，跳过该页，继续检查下一个页面。
- **改进型时钟算法**：优先淘汰未修改的页面，减少写回外存的IO开销。
## 5.内存映射文件(memory-mapped files)
传统只能顺序读文件，使用内存映射文件后可以随机读写文件
- **优点**：
    - 可以像访问普通内存那样访问文件数据，通过指针直接读写文件，而不是调用传统的文件I/O操作
    - 提高处理大型文件时的性能，特别是需要频繁随机访问文件部分内容的场景
- **传统访问方式**：
    1. `open`：打开文件。
    2. `seek`：移动读写指针。
    3. `read`：从当前位置读取数据，磁盘到内存。
    4. `write`：将内存数据写回磁盘，位置由读写指针确定。
- **内存映射文件访问方式**：
    1. `open`：打开文件。
    2. `mmap`：将文件映射到进程的虚拟地址空间（映射后文件内容在内存中，初始为缺页状态）。
## 6.虚拟存储器性能的影响因素及改进方法
缺页率，页大小，工作集和驻留集大小等---
tags:
  - 操作系统
---
# 文件
## 1.文件的基本概念
文件包括文件的属性和操作：  
- 属性（也叫文件==元数据==）包括：名称，标识符，类型，位置，尺寸，权限，创建和修改时间，文件的所有者和使用者等等。  
- 文件的操作包括：创建文件，读文件，写文件，重新定位文件的读写位置，删除文件和截断文件。
FCB文件控制块（目录项）
- 名称，类型，位置（路径），逻辑结构，物理结构，尺寸，权限，创建和修改时间，文件的所有者和使用者，==物理位置==
## 2.文件元数据和索引节点(inode)
*使用inode改造FCB后，将除==文件名称/路径/子目录文件列表==外的其他信息放到inode，并把==物理位置==改成==inode号==，通过inode号去inode表找inode（类似数组下标）*
## 3.文件的操作
1. **文件创建** (`create` 系统调用)  
    用于在文件系统中创建新文件。
2. **文件删除** (`delete` 系统调用)  
    从文件系统中删除指定文件，释放其占用的资源。
3. **文件读取** (`read` 系统调用)  
    从打开的文件中读取数据到内存。
4. **文件写入** (`write` 系统调用)  
    将数据写入到打开的文件。
5. **文件打开** (`open` 系统调用)
    - 使用文件路径和名称，返回文件描述符（fd）作为文件在内存“打开文件表”的序号。
    - 打开文件表的内容：
		1. **文件描述符（fd）**：文件的唯一标识符。
		2. **指向 inode 的指针**：指向文件的 inode 结构体，其中包含文件的元数据，如权限、大小和位置等。
		3. **文件指针（文件偏移量）**：记录当前的读写位置。每次读或写操作都会更新这个指针。
		4. **文件状态标志**：指示文件的状态，例如只读、可写、已关闭等。
		5. **引用计数**：表示有多少进程正在使用该文件，以便在没有进程使用时可以释放资源。
6. **文件关闭** (`close` 系统调用)  
	关闭已打开的文件，使打开计数器-1，如果计数器为0则释放资源。
## 4.文件的保护
1. **口令保护**：
    - 在文件的 FCB（文件控制块）或索引节点中存储口令。
    - 用户打开文件时需输入口令。
    - 优点：实现简单。
    - 缺点：保密性较弱。
2. **加密保护**：
    - 使用异或加密技术：原始文件与密码进行异或操作，存储异或后的数据。读取时再次与密码异或进行解密。
    - 优点：保密性强。
    - 缺点：加密和解密过程消耗时间。
3. **访问控制**：
    - 在文件的 FCB 或索引节点中增加访问控制列表（ACL），记录不同用户对文件的操作权限。
    - 访问控制列表可能很大，尤其是在用户数量多的情况下。
    - 精简访问控制表：将用户分为几个组（如系统管理员、文件主、文件主的伙伴、其他用户），类似于 Linux 系统的用户分组。
    - 权限可以精细化，通常表现为一组 rwx 权限。
    - 也可以将访问控制抽象为矩阵存储，其中行代表用户，列代表权限，矩阵中元素数量与权限个数相同。
## 5.文件的逻辑结构
1. **无结构文件 / 流式文件**：
    - 文件内部数据是二进制流或字符流，如 `.txt` 文件。
    - 数据没有明确的记录结构。
2. **有结构文件 / 记录式文件**：
    - 由若干相似的记录组成，每条记录有多个数据项。
    - 如数据表文件。
    - **顺序文件**：
        - 记录按顺序排列，可以是定长或可变长。
        - **存储方式**：
        - **链式存储**：记录串联，无法随机存取，只能顺序查找。
        - **顺序存储**：
            - 定长记录：可随机读取。
            - 可变长记录：不能随机存储，需要顺序查找。
        - 若使用顺序结构，可通过折半查找提高查询效率。
    - **索引文件**：
        - 使用定长记录（类似数组）替代变长记录。
        - 包含逻辑文件和逻辑表，映射到实际文件。
        - 适用于要求高实时性的场景。
        - 解决了顺序文件在增/删记录时的不便，同时支持随机存取，但索引表可能占用大量空间。
    - **索引顺序文件**：
        - 记录分组，每组有一个索引项。
        - 适用于记录较多时，可建立多级索引表。
    - **直接文件 / 散列文件（Hash File）**：
        - 使用哈希键直接确定物理存储地址，支持快速访问。
## 6.文件的物理结构
1. **非空闲磁盘块管理**：
    - **连续分配**：
        - 每个文件占用一组连续的磁盘块。
        - **优点**：顺序和随机访问效率高，读写速度快。
        - **缺点**：不便扩展，磁盘碎片多。
    - **链接分配**：
        - 文件块分配不连续，块通过链表链接。
        - **隐式链接**：每块存指向下一块的指针，查找效率低，但便于扩展。
        - **显式链接**：通过文件分配表（FAT）存储指针，支持随机访问，但FAT占用内存。
        - 一个磁盘一个FAT，FAT表中的一个条目 记录 “没有下一个块”（-1或EOF） 或 指向下一个簇的地址。FAT32表示使用32位的簇指针
    - **索引分配**：
        - 每个文件有一个索引表，映射==逻辑块号到物理块号==。
        - **优点**：易于扩展。
        - **缺点**：索引表占用磁盘空间，可能需要多层索引或链接方案，导致效率低下。
        - 当磁盘块无法容纳整个索引表时，通常采用**链接方案**和**多层索引**来解决。
			##### 链接方案
			- **原理**：多个索引块通过指针链接在一起，形成链表。在第一个索引块中，会存放指向下一个索引块的指针。
			- **缺点**：当文件非常大时，需要顺序读取前面的索引块，导致访问效率低。
			##### 多层索引
			- **原理**：通过多层索引表来组织文件的索引。例如，第一层索引块存放第二层索引块的位置，形成多级地址映射。
			- **例子**：使用两层索引时，文件最大支持64MB（256×256×1KB）。
			- **缺点**：需要多次磁盘IO来访问每一层索引。
			##### 混合索引
			- **原理**：结合直接索引、一级索引和二级索引，使得文件的索引表同时包含多种类型的索引，优化文件访问效率。
1. **空闲磁盘块的管理**：
    - **存储空间划分**：将磁盘划分为文件卷（逻辑盘），包含目录区和文件区。
    - **几种管理方法**：
        - **空闲表法**：记录空闲起始块号和空闲的盘块数。
        - **空闲链表法**：通过链表管理空闲盘块或盘区。
        - **位示图法**：使用二进制位表示每个盘块的状态，1：已分配  
		0：未分配，然后在矩阵中索引块号
        - **成组链接法**：超级块记录空闲盘块的链头和长度，每个文件一个链表
# 目录
## 1.目录的基本概念
### FCB
### 文件目录结构总结
1. **单级目录**
    - 早期系统采用，整个系统只有一个目录，文件名不能重复。
2. **两级目录**
    - 包括主文件目录（存用户）和用户文件目录（每个用户的文件），用户文件被组织在用户目录下。
3. **多级目录（树形目录）**
    - 树形结构，便于分类和管理文件，更有效的保护文件，但不利于文件共享。
4. **无环图目录结构**
    - 基于树形目录，增加有向边来实现文件共享。多个文件名可以指向同一文件或目录。通过共享计数器管理共享结点，只有当计数器为0时才删除结点。
## 2.树形目录
## 3.目录的操作
新建删除查找等，删除需要把目录下所有子目录和子文件删除
## 4.硬链接和软链接
1. 1. **硬链接**
    - 硬链接通过索引节点连接多个文件名，每个文件名指向相同的inode，多个文件名指向同一数据块。
    - 文件的链接计数（`count`）在inode中，表示有多少个文件名指向该inode。
    - 删除任一硬链接不会删除文件内容，只有最后一个链接被删除时，文件数据和inode才会被释放。
2. **软链接**
    - 软链接可以理解一个特殊文本文件，包含指向目标文件路径的文本信息，类似快捷方式。
    - 软链接和源文件的inode不同，它只包含指向源文件的路径的信息。
    - 删除源文件后，软链接会失效，但软链接文件依然存在。
    - 软链接的创建会新建一个计数为1的inode，对源文件inode不影响
# 文件系统
## 1.文件系统的全局结构(layout)
## 文件系统在外存中的结构
- **主引导记录（MBR）**  
    存储活动分区信息，引导块用于启动操作系统。
- **引导块**  
    用于启动操作系统，位于分区的起始位置。
- **超级块**  
    包含分区的块数、大小，以及空闲块的指针和数量。
- **位示图/指针**  
    管理inode，记录哪些块是空闲的，哪些是已分配的。
## 2. 文件系统在内存中的结构
- **安装表（Mount Table）**  
    记录挂载的分区信息。
- **目录结构的缓存**  
    缓存目录信息，加快访问速度。
- **系统打开文件表**  
    管理系统范围内打开的文件。
- **进程打开文件表**  
    管理每个进程打开的文件。
## 3. 文件系统的全局结构
1. **初始化**
    - **物理格式化**：
        - **分扇区**：划分扇区，检测坏扇区、为每个扇区使用特殊数据结构，包括检验码
	- **分区**：
		- 第一步：将磁盘划分为多个逻辑部分（如C盘、D盘），信息记录在MBR的第二个磁盘块中。
	    - 第二步：逻辑格式化：
	        - **创建文件系统**：如FAT或Unix的索引节点表。
	        - **根目录**：创建文件系统的基础目录。
	        - **确定簇大小**：设置文件分配单元的大小。
2. **引导操作系统**
    - 格式化完成后，通过引导块启动操作系统。
## 2.外存空闲空间管理方法
## 3.虚拟文件系统
- 进程直接访问虚拟文件系统，不用关心文件系统的实现（可能由几个不同的文件系统 统一接口 连接到虚拟文件系统）
- 特性
    - 统一接口
    - 使用vnode统一数据结构（inode实际的->vnode虚拟的）
    - vnode中有函数功能指针指向实际文件系统的功能函数（read/write）
## 4.文件系统挂载(mounting)
**挂载Mounting**是将存储设备的文件系统连接到操作系统的目录结构中，比如U盘连接电脑时可以通过文件目录访问
1. **挂载过程**：操作系统将存储设备（如硬盘、U盘、CD-ROM等）挂载到文件系统树的某个目录上（称为挂载点）。通过该挂载点，用户可以访问存储设备上的文件。
2. **卸载**：当计算机关机时，系统会卸载所有已挂载的存储设备并写入未写入的数据，确保数据完整性和文件系统结构的正确性。
3. **注意事项**：挂载点应选择空目录，避免覆盖系统关键目录。挂载时，原目录中的文件会被隐藏，挂载点下的文件来自挂载的设备。
4. **命令**：在Linux中，`mount`命令用来挂载文件系统，`umount`命令用来卸载文件系统。---
tags:
  - 操作系统
---
# (-)I/O 管理基础
## 1.设备
### 设备的基本概念
极限部件 + 电子部件(IO接口/IO控制器、设备控制器)
### 设备的分类
1. **抽象为文件**：
	- 在Unix系统中，所有外部设备（如硬盘、打印机等）都被抽象为特殊文件，用户可以像操作普通文件一样操作这些设备。
1. **按特性分类**：
    - **存储设备**：用于数据存储（如硬盘、U盘）。
    - **网络通信设备**：用于数据传输（如网卡）。
    - **人机交互设备**：与用户互动（如键盘、鼠标、显示器）。
2. **按信息交换单位分类**：
    - **块设备**：数据以块为单位传输，可以寻址（如硬盘）。
    - **字符设备**：数据以字符为单位传输，通常无法寻址，且常用中断驱动（如键盘、串口设备）。
3. **按设备共享属性分类**：
    - **独占设备**：一次只能由一个进程使用（如某些打印机）。
    - **共享设备**：多个进程可以共享使用（如磁盘）。
    - **虚拟设备**：通过SPOOLing技术使独占设备可共享（如虚拟打印机）。
### I/O接口（I/O控制器）
[总线和输入，输出系统 \> I/0接口(I/0控制器)](../计算机组成原理/总线和输入，输出系统.md#I/0接口(I/0控制器))
### I/O端口
- I/O控制器中的三种寄存器
- 可以与内存统一编址也可以独立编址
- 分别是：
	- 数据寄存器
	- 控制寄存器
	- 状态寄存器
	- 由于控制寄存器和状态寄存器使用时间上错开，有些I/O控制器将它们合二为一
## 2.I/O 控制方式
[总线和输入，输出系统 \> I/0方式](../计算机组成原理/总线和输入，输出系统.md#I/0方式)
### 轮询方式
### 中断方式
### DMA方式
## 3.I/0 软件层次结构
### 中断处理程序
- 接受中断信号（由硬件发出），进行中断处理
### 驱动程序
- 设备驱动程序
    - 设置设备寄存器、检查设备状态
    - 功能
        - 1 接收上层（设备独立软件）命令并翻译
        - 2 检查io合法性
        - 3 发出io命令
        - 4 发送设备控制命令（CPU控制IO设备时不需要中断，跳过中断处理程序）
### 设备独立软件
#### 为用户层软件提供系统调用的接口
- **输入/输出应用程序接口**：
    - **字符设备接口**：用于处理字符设备。
    - **块设备接口**：用于处理块设备。
    - **网络设备接口**（网络套接字接口）：用于网络通信，包含`bind`、`connect`、`read/write`等操作。
- **阻塞/非阻塞I/O**：区分用户进程是否因I/O操作而被阻塞（如`scanf`为阻塞操作）。
#### 设备保护
类似文件保护，权限方式
#### 差错处理
#### 设备分配与回收
- 使用LUT实现
	- **逻辑设备表(LUT)**：实现逻辑设备名与物理设备名的映射。
### 用户层 I/0软件
使用系统调用送信息到设备独立软件
## 4.输入/输出应用程序接口
[输入输出(I0)管理 \> 为用户层软件提供系统调用的接口](../操作系统/输入输出(I0)管理.md#为用户层软件提供系统调用的接口)
# (二)设备独立软件
## 1.缓冲区管理
#### 磁盘高速缓存
磁盘高速缓存（Disk Cache）利用内存存储磁盘数据的副本，加速磁盘I/O操作。访问内存中的缓存比直接访问磁盘更为高效。
- **缓存类型**：
    - 固定大小缓存：在内存中开辟一个专用区域作为缓存，大小固定。
    - 动态缓存池：未使用的内存空间作为共享缓冲池，支持分页系统和磁盘I/O请求。
####  缓冲区（Buffer
缓冲区的主要作用是缓解CPU与I/O设备之间的速度不匹配，减少中断频率，提高并行性。
- **缓冲区实现方式**：
    - **硬件缓冲器**：通常不普遍使用，成本高。
    - **内存缓冲区**：更常见，通过内存中的缓冲区提高效率。
#### 缓冲技术
- **单缓冲**：使用一个缓冲区，数据先存入缓冲区，I/O设备或处理机从中取数据。处理过程较为简单，但存在等待问题。
- **双缓冲**：使用两个缓冲区，设备填充一个缓冲区时，处理机可以处理另一个缓冲区的数据，从而提高并行性。
- **循环缓冲**：多个缓冲区组成环形结构，两个指针（in/out）控制数据的输入与输出，适用于高效的数据交换。
- **缓冲池**：由多个共享缓冲区组成，按使用状况分为不同队列，能有效管理数据流。
	- 用于收容输入数据的工作缓冲区
	- 用于提取输入数据的工作缓冲区
	- 用于收容输出数据的工作缓冲区
	- 用于提取输出数据的工作缓冲区
## 2.设备分配与回收
#### **设备分配时考虑的因素**
- **设备的固有属性**：
    - **独占设备**：一次只能被一个进程使用。
    - **共享设备**：多个进程可以并行使用。
    - **虚拟设备**：由系统模拟，不直接对应物理设备。
- **设备分配算法**：
    - **安全性考虑**：
	    - **安全分配方式**：每个进程一次只使用一个设备，避免死锁。缺点是进程无法并行执行CPU和I/O任务。
	    - **不安全分配方式**：允许进程同时使用多个设备，提高效率，但可能导致死锁。
	- **静态与动态分配**：
	    - **静态分配**：进程运行前分配所有设备，结束时归还。适用于独占设备。
	    - **动态分配**：进程在运行时动态申请资源，适用于共享设备。
	- **常用分配策略**：
	    - 先来先服务（FCFS）
	    - 最高优先级算法
#### **设备分配的步骤**
- 从物理设备名出发，通过 **SDT**、**DCT**、**COCT**、**CHCT** 进行设备的分配管理。
	- **通道控制表 (CHCT)**：每个通道一张，记录通道的操作和管理信息。
	- **控制器控制表 (COCT)**：每个控制器一张，记录设备控制器的信息。
	- **设备控制表 (DCT)**：每个设备一张，记录设备的使用情况（忙/等）
	- **系统设备表 (SDT)**：每个系统一张，记录系统中所有设备的总表。
#### **设备分配的改进方法**
- 通过逻辑设备名映射到物理设备名，并记录在 **LUT**（逻辑设备表）中，简化设备的管理。
## 3.假脱机技术(SPOOLing)
#### **脱机技术**
- **定义**：脱机技术指的是设备在与主机脱离直接控制的情况下进行输入/输出操作。
#### **假脱机技术（SPOOLing）**
- **概念**：假脱机技术是通过软件模拟脱机技术，使得I/O操作不再由CPU直接控制，而是通过外围控制机进行管理。
- **组成部分**：
    - **输入井与输出井**：数据存储在磁盘中，本质是文件队列
    - **输入缓冲区与输出缓冲区**：内存中的缓冲区，用于暂存数据。
- **工作原理**：
    - **输出过程**：用户进程产生输出数据，送入输出井，再由外围控制机传送到打印机等输出设备。
    - **输入过程**：输入设备（如键盘）将数据送入输入井，再通过外围控制机传输到用户进程。
## 4.设备驱动程序接口
系统对驱动程序的要求，必须使用规定的接口才能接入操作系统，为设备独立性软件提供服务
# (三)外存管理
## 1.磁盘
### 磁盘结构
- **磁盘**：由表面涂有磁性物质的圆形盘片组成，用于存储数据。
- **磁道**：每个盘片被划分为多个同心圆形的磁道，用于存储数据。
- **扇区**：每个磁道又被划分为若干扇区，是磁盘读写的最小单位，通常大小为512字节。
### 格式化
#### 1. **磁盘初始化**
- **低级格式化（物理格式化）**：为磁盘划分扇区
- **分区**：将磁盘划分为多个逻辑区域，每个区域可单独管理。
- **逻辑格式化**：创建文件系统，生成目录结构等，使磁盘能够存储文件数据。
#### 2. **引导块**
- **功能**：存储初始化程序（自举程序），用于启动计算机。
- **位置**：引导块位于磁盘的固定位置（通常是启动分区），包含完整的自举程序，确保计算机能够引导操作系统。
#### 3. **坏块管理**
- **简单磁盘**：在逻辑格式化时，标记坏块，避免使用这些扇区。
- **复杂磁盘**：磁盘控制器维护一个坏块链，并管理备用扇区，确保坏块不影响数据存储和访问。
### 分区
### 磁盘调度方法
#### 1. **先来先服务 (FCFS)**
- **概述**：按请求到达的顺序处理磁盘寻道请求。
- **优点**：实现简单。
- **缺点**：可能导致较长的平均寻道时间，效率低。
#### 2. **最短寻找时间优先 (SSTF)**
- **概述**：优先处理与当前磁头最近的磁道。
- **优点**：性能较好，平均寻道时间短。
- **缺点**：可能产生“饥饿”现象，某些磁道请求长时间得不到处理。
#### 3. **扫描算法 (SCAN)**
- **概述**：磁头在一个方向上一直移动，直到到达最边缘的磁道，然后改变方向，继续移动。
- **缺点**：只有到达最边上的磁道时才能改变磁头的移动方向。
#### 4. **LOOK 调度算法**
- **概述**：与扫描算法类似，但磁头在没有请求的情况下可以改变方向，而不必到达最边上的磁道。
- **优点**：提高了效率，避免了无请求的无意义移动。
#### 5. **循环扫描算法 (C-SCAN)**
- **概述**：磁头始终沿一个方向移动，若到达最边缘，则快速返回起始端，并继续处理请求。
- **缺点**：返回过程中不处理请求，可能造成部分请求延迟。
#### 6. **C-LOOK 调度算法**
- **概述**：类似于C-SCAN，但磁头只回到最靠近边上的磁道，而不需要到最边上。
- **优点**：效率更高，减少了不必要的磁头移动。
## 2.固态硬盘
#### 1. **原理**
- 基于闪存技术（Flash Memory），属于电可擦除ROM（EEPROM）。
#### 2. **组成**
- **闪存翻译层**：负责将逻辑块号转换为对应的物理页。
- **存储介质**：由多个闪存芯片（Flash Chip）组成，每个芯片包含多个块（Block），每个块包含多个页（Page）。
#### 3. **读写性能特性**
- 以**页**为单位进行读写，类似磁盘的“扇区”。
- 以**块**为单位进行擦除，擦除后可以写入新的数据。
- **随机访问**性能高，通过闪存翻译层迅速定位物理地址。
- **读快、写慢**，写入时需复制块内其他页到新的块，再写入新数据。
#### 4. **磨损均衡技术**
- **动态磨损均衡**：优先选择擦除次数少的闪存块进行写入，延长寿命。
- **静态磨损均衡**：自动监控并分配数据，让老旧块承担读任务，减少写入负担。