---
tags:
  - 数据结构
---
# 基本概念
- 数据    
- 数据元素、数据项    
- 数据对象、数据结构
## 程序=数据结构+算法---
tags:
  - 数据结构
---
# 概念
相同数据结构，有次序，有限的数据结构
# 实现方式
## 顺序表
## 链表
# 应用
文件系统的FAT，inode表等---
tags:
  - 数据结构
---
# 栈
## 卡特兰数
n个不同元素进栈的排列个数
$$ C_n =  \frac{1}{n+1} C^{n}_{2n} = \frac{(2n)!}{(n+1)!n!} $$
## 顺序结构
```C
typedef struct { 
	int data[MAX_SIZE]; 
	int top;
} Stack;
```
注：top=-1时栈空
## 链式结构
// 链表节点 
```C
typedef struct Node { 
	int data; 
	struct Node* next;
} Node; 
// 栈结构体 
typedef struct { 
	Node* top; 
} LinkedStack;
```
# 队列
## 顺序结构
```C
typedef struct { 
	int data[MAX_SIZE]; 
	int front; // 队头 
	int rear; // 队尾 
} Queue;
```
## 链式结构
```C
// 链表节点 
typedef struct Node { 
	int data; 
	struct Node* next;
} Node; 
// 队列结构体 
typedef struct { 
	Node* front; // 队头 
	Node* rear; // 队尾 
} LinkedQueue;
```
# 栈与队列的应用
## 括号匹配
遇到左括号入栈，右括号出栈
## 中缀转后缀（使用栈）
1. 遇到数字直接输出
2. 遇到符号弹出栈内优先级比大于等于它的，然后再入栈
3. 遇到“(”入栈，遇到“)”出栈，一直出栈直到遇到“(”，括号不加入后缀表达式
## 后缀计算
1. 数字入栈
2. 操作符弹出两个操作数，操作完后再入栈
## 中缀计算
1. 遇到数字进数字栈
2. 遇到符号弹出栈内优先级比大于等于它的，弹出时弹出两个数字栈中的数字运算后压回数字栈，最后在把操作符入操作符栈
# 数组
## 多维数组的存储
行优先和列优先
## 数组压缩
1. （行，列，值）三元组存储稀疏矩阵
2. 游程编码压缩存储：遇到连续的5个6，使用（6，5）存储---
tags:
  - 数据结构
---
# 二叉树
## 存储
### 顺序存储
左结点是2n，右结点是2n+1
### 链式存储
一个结点两个node*，n个结点的二叉链表共有n+1个空链域
## 性质
1. 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1
## 遍历
### 先序遍历
中左右
#### 使用栈实现
出栈输出值，同时右结点进栈，然后左结点进栈
```C
while (!stack.isEmpty()) {
	TreeNode node = stack.pop();
	ans.add(node.val);
	if (node.right != null) {
		stack.push(node.right);
	}
	if (node.left != null) {
		stack.push(node.left);
	}
}
```
### 中序遍历
左中右
#### 使用栈实现
先一直往左遍历并入栈，如果遍历到空就出栈输出结点，然后转到右结点进行下一个循环（一直遍历左结点）
```c
TreeNode cur = root; 
while (!stack.isEmpty() || cur != null) { 
	if (cur != null) { 
		stack.push(cur); cur = cur.left; } 
	else { 
		TreeNode node = stack.pop(); 
		ans.add(node.val); 
		cur = node.right; }
} 
```
### 先序遍历
左右中
#### 使用栈实现
1. 使用两个栈：一个栈用于存储节点，另一个栈用于存储访问的顺序。
2. 然后，处理当前节点的右子节点和左子节点，按照右子节点先入栈的顺序。
3. 最终，当栈为空时，从第二个栈中取出元素，得到后续遍历的结果。
```C
TreeNode cur = root;
stack.push(cur);
while (!stack.isEmpty()) {
	TreeNode node = stack.pop();
	// 先存一个栈里面
	helper.push(node);
	// 先序遍历的时候，是先判断右树，改造一下，先判断左树
	if (node.left != null) {
		cur = node.left;
		stack.push(cur);
	}
	if (node.right != null) {
		cur = node.right;
		stack.push(cur);
	}
}
while (!helper.isEmpty()) {
	ans.add(helper.pop().val);
}
```
## 线索二叉树
#### 使用tag标记位判断左右孩子是真的左右孩子还是前驱后继
tag为1时是线索，tag为0是孩子
#### 找前驱后继
中序
	前驱
		tag=0时找左节点的最右下孩子直到tag=1
	后继
		tag=0时找右节点的最左下孩子直到tag=1
先序
	前驱
		找不到！！！
		不在左右子树中，找到父节点才能找到
	后继
		找左孩子
		没左孩子找右孩子
后序
	前驱
		找右孩子
		没右孩子找左孩子
	后继
		找不到！！！
		不在左右子树中，找到父节点才能找到
# 树
## 存储
双亲表示法：数组存所以结点与其对应的双亲（并查集）
孩子表示法：类似邻接链表
孩子兄弟表示法：转为二叉树存储，存长子+兄弟
## 遍历
| 森林  | 树   | 二叉树 |
| --- | --- | --- |
| 先序  | 先序  | 先序  |
| 中序  | 后序  | 中序  |
## 互相转换
左长子右兄弟
# 树与二叉树的应用
## 哈夫曼树和哈夫曼编码
### 带权路径长度
#### 结点的带权路径长度
从树的根节点 到 该结点的路径程度(经过的边数)与该结点上权值的乘积
#### 树的带权路径长度
树的所有结点的带权路径长度之和
# 堆及其应用
## 建堆
### 上滤建堆
一个一个插入到最后，然后不断上移直到符合堆，复杂度nlogn
### 自下向上
从第n/2个元素开始检查是否符合大/小根堆的性质，不符合则调整（如果左/右节点进行了调整，还要继续检查左/右是否符合堆性质），从第n/2个检查到第一个
## 应用
### 优先队列
使用小根堆维护优先队列，实现输出一个队列的最小值
### 动态中位数
一个大根堆一个小根堆得到中位数
### 快速找到第K大的或第K小的元素
维护一个大小为K的堆---
tags:
  - 数据结构
---
# 概念
多重图：有重复/指向自己的边
路径：不出现重复的顶点
连通：无向图，任意两个结点有路径
强连通：有向图，每个结点都有路径到图中剩余的所有结点
连通分量：无向图，最大连通子图
强连通分量：有向图，最大强连通子图
完全图：任意两个结点都有双向的边
# 存储
## 邻接矩阵(顺序存储)
邻接矩阵的n次方表示顶点i和顶点j之间是否有长度为n的路径，有则为0		
$$\begin{matrix}{}
A =  {\begin{matrix}{}
0&1&0&1\\
1&0&1&0\\
0&1&0&1\\
1&0&1&0
\end{matrix}} \\
{A^2} = {\begin{matrix}{}
2&0&2&0\\
0&2&0&2\\
2&0&2&0\\
0&2&0&2
\end{matrix}}
\end{matrix}$$
## 邻接表(顺序+链式)
找入度的弧不方便,需要遍历全部指针
## 十字链表/存储有向图
每条弧用一个数据结构存储，可以找到弧头相同的下一条弧/弧尾相同的下一条弧；每个顶点存该顶点作为弧头的第一条弧和该顶点作为弧尾的第一条弧
## 邻接多重表/存储无向图
如果使用 邻接矩阵或邻接表存储，每一条边都存在两份相同的数据。
邻接多重表存边，存边的两头ij和依附于顶点i的下一条边依附于顶点j的下一条边
# 遍历
## BFS
## DFS
## 可以用来求连通分量数
每个连通分量只需要调用一次DFS或BFS，因此调用次数等于连通分量的数量。
# 应用
## 最小代价生成树
### Prim/普里姆 算法
从某一个顶点开始构建生成树；
每次将代价最小的新顶点纳入生成树，知道所有顶点都纳入为止
时间复杂度O(|V|^2)适用于边稠密图
### Kruskal/克鲁斯卡尔 算法
每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)；直到所有结点都连通
时间复杂度O( |E| log以2为底的 |E| )适用于边稀疏图
## 最短路径问题
#### 单源最短路径
##### BFS算法(无权图)
广度优先遍历去计算最短路径
##### Dijkstra/地杰斯特拉 算法
###### 算法内容
三个数组
final检查结点是否已经找到最短路径
dist表示源结点到目标结点的最短路径
path表示路径的前驱
###### 时间复杂度
On^2 即 OV^2;
不能使用于有负权值的带权图
#### 每对顶点间的最短路径
##### Floyd/弗洛伊德 算法
###### 复杂度
时间复杂度 O v^3;
空间复杂度 O v^2;
###### 不能解决的问题
带有负权回路的图
###### 步骤
遍历矩阵，第一次运行使用v0中转，遍历9个元素，v0-v0-v0，v0-v0-v1... ...v2-v0-v1，v2-v0-v2
下一趟遍历允许使用v1中转
## 表达式问题
使用有向无环图表示表达式
操作数放在最底下，按顺序一层一层向上叠操作符
## 拓扑排序
- 从 AOV 网中选择一个没有前驱 (入度为0) 的顶点并输出
- 从网中删除该顶点和所有以它为起点的有向边
- 重复 1、2 直到当前 AOV 网为空
- 可以判断是否有回路
## 关键路径
事件是点活动是边
求所有事件的最早发生时间 ve()
求所有事件的最迟发生时间 vI()
求所有活动的最早发生时间 e()=边的起点的ve
求所有活动的最迟发生时间 I()=边的终点的vl-边的持续时间
求所有活动的时间余量 d()=l-e
d=0的就是关键路径---
tags:
  - 数据结构
---
# 查找的基本概念
查找长度
	查找运算中，需要对比关键字的次数
平均查找长度 ASL Average Search Length
	所有查找过程中进行关键字比较次数的平均值
# 顺序查找法
从头到尾挨个找
# 分块查找法
“索引表”中保存每个分块的最大关键字和分块的存储区间
块内无序，块间有序
# 折半查找法
```C
typedef struct {
    ElemType *elem;   // 动态数组基址
    int TableLen;     // 表的长度
} ssTable;
// 折半查找
int Binary_Search(ssTable L, ElemType key) {
    int low = 0, high = L.TableLen - 1, mid;

    while (low <= high) {
        mid = (low + high) / 2;

        if (L.elem[mid] == key) {
            return mid; // 找到目标元素，返回索引
        } else if (L.elem[mid] > key) {
            high = mid - 1; // 目标元素在前半部分
        } else {
            low = mid + 1; // 目标元素在后半部分
        }
    }

    return -1; // 查找失败，返回-1
}
```
# 树形查找
## 二叉搜索树
左子树结点值 < 根结点值 < 右子树结点值
中序遍历，可以得到一个递增的有序序列
删除时，只有一颗子树就用子树顶替，两颗子树就用前继/后继顶替
## 平衡二叉树
结点的平衡因子=左子树高 - 右子树高
### 调整最小不平衡子树
找最小不平衡子树根结点（平衡因子为2/-2），然后LL第一个L表示根结点的左孩子，第二个L表示根结点的左孙子
#### LL 在左子树的左孩子处插入新结点
第一个L右旋
#### RR 在右子树的右孩子处插入新结点
第一个R左旋
#### LR 在左子树的右孩子处插入新结点（根LR）
R先左旋代替L，L再右旋代替根
#### RL 在右子树的左孩子处插入新结点（根RL）
L先右旋顶替R，R在左旋顶替根
### 平衡二叉树的删除
树中结点通过前驱后继转换为删除叶结点
一路向北（叶向根遍历）找不平衡然后调整
调整后可能导致新的不平衡向上传递，只需继续一路向北
## 红黑树
### 性质
- 左右子树高度差，不超过2倍
- 左根右、根叶黑、不红红、黑路同
### 插入
先查找，确定插入位置(原理同二叉排序树)，插入新结点
新结点是根
- 染为黑色
新结点非根
- 染为红色
若插入新结点后依然满足红黑树定义，则插入结束
若插入新结点后不满足红黑树定义，需要调整，使其重新满足红黑树定义
`黑叔:旋转+染色`（没叔叔默认黑叔）
LL型:右单旋，交换的结点是父爷，父爷换色
RR型:左单旋，交换的结点是父爷，父爷换色
LR型:左、右双旋，交换的结点是子爷，子爷换色
RL型:右、左双旋，交换的结点是子爷，子爷换色
`红叔:染色+变新`
叔父爷染色，爷变为新结点
## B树
### 如何保证查找效率
- 处理根节点外，任何结点至少有 $\lceil \frac{m}{2} \rceil$ 个分叉，即至少含有 $\lceil \frac{m}{2} \rceil - 1$ 个关键字。
- 对于任何一个结点，其所有子树的高度都要相同
### 定义
- 根节点的子树数量，最少为2
- 除根节点至少有m/2个分支，至少含有m/2-1个关键值（m/2向上取整）
### 高度
$$\log_{\lceil m \rceil}(n+1) \leq h \leq \log_{\lceil m/2 \rceil}\left(\frac{n+1}{2}\right) + 1$$
### B树的插入删除
#### 插入
- 若导致原结点关键字数超过上线，从中间位置将关键字分为两部分。中间位置 $\lceil \frac{m}{2} \rceil$ 作为原结点的父节点
- 新元素插入到终端结点、用查找确定位置
#### 删除
- 若删除关键字在非终端结点，用直接前驱或直接后继 替代被删除元素
- 删除后，关键字数目小于$\lceil \frac{m}{2} \rceil-1$。
	- 借兄弟的
	- 兄弟内元素、借出后小于$\lceil \frac{m}{2} \rceil-1$，合并当前和兄弟
## B+树
### 定义
只有叶子结点存数据，非叶子结点存其所有子结点的最大值
### 性质
- 在B+树中，非叶结点不存储该关键字对应记录的存储地址。此结点所占空间更小。一个磁盘块可存储更多结点。读磁盘次数更少，查找更快
- 叶结点支持顺序查找
# 散列表
## 处理冲突的方法
### 通过拉链法/链接法/链地址法处理冲突
### 开放定址法（发生冲突时可以存到非同义词表项）
#### 线性探测法
- 发生冲突时，每次向后探测相邻的下一个单元是否为空
- `删除时，为逻辑删除。`用一个tag逻辑删除，表示这个数可以被替换，计算查找失败的查找长度时需要算上
#### 平方探测法
- 散列表长度m必须是一个可以表示成 4j+3 的素数，才能探测到所有位置
#### 伪随机序列法
### 再散列法
- 准备多个散列函数，发生冲突，用下一个散列函数计算新地址
## 概念
- 平均查找长度 ASL
	- 分成功情况失败情况    
- 装填因子α = 表中记录数/散列表长度
# 字符串模式匹配
## KMPnext数组
不算当前，前面的最长公共前后缀
## 失配时
直接向右移动next数组的值个位置---
tags:
  - 数据结构
---
# 插入排序
## 直接插入排序
插入到前面已经排好序的子序列中
## 折半插入排序
与前边已经排序号的序列比较时，使用折半查找，比较关键字的次数减少了
## 希尔排序
使用增量d划分为子表，然后不断减小d
# 交换排序
## 冒泡排序
两两比较时，元素相同，不做处理，以保证算法稳定性
若某一趟排序没有发生 交换 说明此时已经整体有序。算法可提前结束，所以比较次数与初始序列有关
## 快速排序
在待排序表中任取一个元素 pivot 作为枢轴/基准，通常取首元素
通过一趟排序将待排序表划分为独立的两部分，使得左部分元素都小于 pivot，有部分元素都大于pivot，则 pivot 放在了其最终位置，这个过程称为一次 划分
分别递归的对两个字表重复上述过程。
# 选择排序
定义
每一趟在待排序元素中，选取关键字最小(或最大)的元素加入有序子序列
分类
## 简单选择排序
每一趟在待排序元素中选取关键字最小的元素加入有序子序列
有两个最小的，取左边的，不稳定
## 堆排序
### 建立堆
#### 由初始序列建立大根堆
[树与二叉树 \> 自下向上](../数据结构/树与二叉树.md#自下向上)
### 基于大根堆进行排序
假设大根堆大小为n
1. 将大根堆的堆顶元素（最大的）与待排序序列中的最后一个元素交换
2. 对剩下的n-1个元素重新调整为大根堆
### 堆插入
元素插在表尾
与父节点比较，不满足堆的要求，就上升，交换父节点和当前结点
### 堆删除
使用堆尾元素替代
然后下坠，只需要对比换上来的堆底元素，使其下坠即可
# 归并排序和基数排序
## 归并排序 Merge Sort
把两个或多个 已经有序的 序列合并成一个
### 最佳归并树
带权的归并需要构造哈夫曼树
#### n路归并的情况
每次选择权值最小（读写次数/磁盘块数最少）的两颗子树，构成新树
#### n路归并的情况
与二路归并相似，每次选择n个权值最小的结点
##### 补充虚段的数量
若初始数量，无法构成严格的K叉归并树（只包含度为k和度为0的结点），应该初始补长度为 0 的 虚段，再进行构造哈夫曼树
$$\left\{
\begin{array}{c}
    n=n_0+n_k \\
    n_k\cdot k = n-1 \\
\end{array}
\right.$$
得到$$n_k=\frac{n_0-1}{k-1}$$
## 基数排序 Radix Sort
顺序：个十百/日月年
# 不稳定/与初始无关
- 不稳定：希儿快速选择堆
- 与初始无关：快速选择归并基数(快选龟基)
# 外部排序
## [排序(数据结构) \> 最佳归并树](../数据结构/排序(数据结构).md#最佳归并树)
## 败者树
可视为一棵完全二叉树，多了一个头头。
k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆 左右子树中的 “失败者” ，而让胜者往上继续进行比较，一直到根节点
## 置换选择排序
通过有限的缓冲区构建不等长的初始归并段
比如缓冲区大小为3，构建时使用MINIMAX当前归并段的最大值
- 4 9 6 5 2，MINIMAX先4后9然后缓冲区652都比MINIMAX小，只能新建归并段，得到一个归并段4，9 