---
tags:
  - 操作系统
---
# 进程与线程
## 1.进程与线程的基本概念
进程=PCB+程序段+数据段
线程是轻量级的进程，是处理机调度的最小单位
## 2.进程/线程的状态与转换
### 五状态
1. **就绪态 (Ready)**：进程已准备好运行，但因没有空闲CPU而暂时等待。
2. **运行态 (Running)**：进程正在占用CPU并执行。
3. **阻塞态 (Waiting/Blocked)**：进程因等待某个事件（如I/O操作）而暂时不能运行。
4. **创建态 (New)**：进程正在被创建，操作系统为其分配资源并初始化进程控制块 (PCB)。
5. **终止态 (Terminated)**：进程完成后，正从系统中撤销，操作系统回收资源并撤销PCB。
### 状态转换
1. **创建态到就绪态**：系统完成创建进程的所有工作
2. **就绪态到运行态**：进程被调度
3. **运行态到阻塞态**：进程主动使用*系统调用*请求系统资源或等待某个事件发生
4. **运行态到就绪态**：进程时间片到 或 被抢占
5. **阻塞态到就绪态**：当申请的资源被分配或等待的事件发生
6. **运行态到终止态**：进程完成运行或遇到不可修复的错误
## 3.线程的实现
### 线程库支持的线程
早期操作系统不支持线程，只能使用线程库（在用户态）在进程里模拟线程
### 内核支持的线程
有内核级的线程，用户线程对应内核进程有三种模型
- 一对一
- 多对一
- 多对多
## 4.进程与线程的组织与控制
### 组织
PCB中的state变量表示进程当前状态（阻塞还是就绪等）
1. **链接方式**：
- 按照进程状态（state）将PCB分为多个队列
- 操作系统持有指向各个队列的指针
2. **索引方式**：
 - 根据不同的进程状态建立多张索引表
 - 操作系统持有指向这些索引表的指针
### 控制
#### 原语与系统调用的区别
- ==系统调用是用户使用，让操作系统从用户态到内核态==
- ==原语是操作系统内核态下的一小段程序，操作系统通过原语调用硬件==
通过原语来实现进程状态转换（改变PCB的值和指针指向的队列），原语执行时必须一气呵成且不可中断
1. **创建原语**：进程的创建。
2. **撤销原语**：进程的终止。
3. **阻塞原语**：使进程进入阻塞状态。
4. **唤醒原语**：使阻塞的进程进入就绪状态。
5. **切换原语**：进行进程切换。
注：3.4.阻塞和唤醒成对使用，保证CPU“无缝衔接”
## 5.进程间通信
### 共享内存
- 系统为两个进程开辟一块共用的存储空间
- 两个进程互斥访问
- 可以由系统限制存储区的数据结构，也可以由两个进程自行协商
### 消息传递
进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
1. **直接通信方式**：消息带有接收方ID，发送到接收方的消息队列，接收原语根据ID查找消息。
2. **间接（信箱）通信方式**：消息先发送到一个中间体（信箱），由接收方从信箱中获取消息。
### 管道
管道通信是循环队列，内存中开辟一个固定大小的缓冲区（通常为一个页大小），使用文件描述符来实现，创建时会有一个fd0用来读，一个fd1用来写
1. **先进先出**：数据按顺序读写。
2. **半双工通信**：数据只能单向传输，使用两个管道可以实现双向通信。
3. **互斥访问**：进程访问管道时需互斥，写满时无法写，读空时无法读，写未满时无法读，读未空时无法写。
### 信号
使用类似singal/wait的操作
### CPU调度与上下文切换
## 1.调度的基本概念
1. **高级调度（作业调度）**：从外存的作业队列中挑选作业调入内存并创建进程，调出时撤销进程的PCB。每个作业只调入一次，调出一次。
2. **中级调度（内存调度）**：当内存不足时，将部分进程的数据调到外存，进程处于挂起状态。内存充足时，将挂起的进程重新调入内存。中级调度频率高于高级调度。
3. **低级调度（进程调度）**：从就绪队列中选取进程，分配处理器。进程调度是操作系统中的基本调度，频率很高，通常几十毫秒执行一次。
## 2.调度的目标
1. 响应速度尽可能快  
2. 进程处理的时间尽可能短  
3. 系统吞吐量极可能大(单位时间完成作业的数量)  
4. 资源（CPU）利用率尽可能高  
5. 对所有进程要公平  
6. 避免饥饿  
7. 避免死锁
### 指标
- 周转时间
    - 作业被提交给系统开始，到作业完成为止的这段时间间隔  
- 带权周转时间
    - 作业周转时间/作业实际运行的时间
- 等待时间
    - 进程、作业处于等待处理机状态时间之和。
- 响应时间
    - 从用户提交请求道首次产生相应所用的时间。
## 3.调度的实现
### 调度器/调度程序(scheduler)
操作系统中的组件，作用：
- 分配CPU时间
- 进程/线程状态切换
- 调度CPU或IO设备等其他资源
- 保证系统性能和调度公平
### 调度的时机与调度方式(抢占式/非抢占式)
#### 调度的时机
- 主动放弃
    - 进程正常终止
    - 运行过程中发生异常而终止
    - 主动阻塞(如 等待I/O)
- 被动放弃
    - 分给进程的时间片用完
    - 有更紧急的事情需要处理(如 I/O中断)
    - 有更高优先级的进程进入就绪队列
#### 不能调度的时机
- 在处理中断的过程中
- 进程在操作系统内核程序临界区中
    - 临界资源:一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
    - 临界区:访问临界资源的那段代码。
    - 普通临界区可以调度，内核临界区不行
- 原子操作过程中(原语)
#### 调度方式    
- 非剥夺调度方式(非抢占式)
    - 只能由当前运行的进程主动放弃CPU
- 剥夺调度方式(抢占式)
    - 可由操作系统剥夺当前进程的CPU使用权
### 闲逛进程
- 没有其他就绪进程时运行的进程
- 优先级最低
- 可以是0地址指令，占用完整的指令周期（周期末检查中断）
- 能耗低
### 内核级线程与用户级线程调度
1. **用户级线程：**
    - 线程管理在用户空间，由线程库提供。
    - 操作系统仅看到进程，无法直接调度线程。
    - 只能在单核上运行，无法实现并行加速。
    - 线程阻塞时，整个进程阻塞，效率低。
    - 可以定制调度算法，灵活性高。
    - 线程切换不涉及内核，开销小。
2. **内核级线程：**
    - 线程管理在内核空间，由操作系统调度。
    - 操作系统能够看到线程，可在多个CPU核心上并行调度。
    - 线程阻塞时，其他线程不受影响，效率高。
    - 切换线程时需要进入内核，开销较大。
    - 用来记录系统里所有线程的线程表有限，扩展性差。
## 4.CPU 调度算法
1. **先来先服务（FCFS）**：
    - 按照进程到达的顺序进行调度。
    - 优点：算法简单。
    - 缺点：对长作业有利，不利于短作业，且效率较低。
2. **短作业优先（SJF）**：
    - 优先调度要求服务时间最短的进程。
    - 分类：抢占式和非抢占式。
    - 优点：平均等待时间最少，但不可预知所有进程的服务时间。
3. **高响应比优先（HRRN）**：
    - 综合考虑进程的等待时间和服务时间，选择响应比最高的进程进行调度。
    - 响应比 = (等待时间 + 服务时间) / 服务时间。
4. **时间片轮转（RR）**：
    - 每个进程轮流获得一个时间片，时间片结束后，如果进程未完成，则重新排队。
    - 优点：公平，但时间片大小对性能有影响。
    - 时间片过大会退化为FCFS，过小则频繁切换进程，影响效率。
5. **优先级调度**：
    - 按优先级高低选择进程。
    - 分类：抢占式和非抢占式，静态和动态优先级。
    - 动态优先级：根据等待时间和I/O频率调整优先级。
6. **多级反馈队列调度**：
    - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
    - 只有第k级队列为空时，才会为k+1 级队头的进程分配时间片
## 5.多处理机调度
1. **单队列多处理机调度（SQMS）**：
    - 所有任务放在一个队列中，简单易实现。
    - 存在扩展性差和性能受限问题，特别是在多CPU情况下。
    - 采用锁机制保证正常运行，但可能降低性能。
    - 引入亲和度机制，尽量让任务在同一CPU上运行，以减少缓存问题。
2. **多队列多处理机调度（MQMS）**：
    - 将任务分配到多个队列，每个队列调度不同的任务。
    - 存在负载不均衡问题，可能导致某些CPU空闲（队列空），而其他CPU负载过重（队列满）。
    - 采用 **工作窃取（Work Stealing）** 策略：低负载（空）队列从高负载（满）队列窃取任务，确保负载均衡。
## 6.上下文及其切换机制
上下文就是寄存器和程序计数器等信息，切换就是把上一个的保存起来，引入下一个的
1. **进程上下文切换**：
    - 发生在不同进程之间的切换。
    - 时机：时间片耗尽、资源不足、主动挂起、优先级更高的进程、硬件中断等。
    - 切换需要保存和恢复进程的全部资源，如虚拟内存、寄存器等。
2. **线程上下文切换**：
    - 发生在同一进程内的线程切换。
    - 两种情况：
        - **同进程内的线程切换**：共享资源，只需保存和恢复线程私有数据、寄存器等。
        - **不同进程的线程切换**：类似进程上下文切换，需要保存和恢复更多资源。
    - 相较于进程切换，线程切换开销更小。
3. **中断上下文切换**：
    - 发生在中断处理时，CPU被中断，转而执行中断处理程序。
    - 只需保存和恢复内核态资源，如寄存器、内核堆栈等，不涉及用户态的资源。
# 同步与互斥
## 1.同步与互斥的基本概念
## 2.基本的实现方法
### 软件方法
#### 单标志法
- **原理**：两个进程在访问完临界区后，将使用权限转交给另一个进程。进入临界区的权限仅能由其他进程赋予。
- **逻辑**：体现“谦让”原则。
- **问题**：违背“空闲让进”原则。
#### 双标志先检查
- **原理**：使用布尔型数组`flag[]`标记各进程进入临界区的意愿。一个进程进入前检查其他进程是否有意，若没有进程想要进入才设置自己的`flag[i]`为true。
- **逻辑**：表达进入意愿。
- **问题**：违背“忙则等待”原则。检查和上锁的过程不是一气呵成，进程同时进入临界区
#### 双标志后检查
- **原理**：先设置状态（上锁）再进行检查（其他进程意愿）
- **问题**：违背“空闲让进”和“有限等待”原则，可能导致进程长期无法访问临界资源，产生“饥饿”。
#### Peterson算法
- **原理**：结合单标志法与双标志法的思想，当两个进程争抢临界区时，采用谦让策略。
- **步骤**：
    1. 设置自己的`flag[]`以主动争取。
    2. 设置对方的`turn[]`以主动谦让。
    3. flag和trun都是对方的值时等待
- **优点**：遵循“空闲让进”、“忙则等待”和“有限等待”原则。
- **问题**：不满足“让权等待”原则。
```C
Pi:
flag[i] = ture; turn = j;
while (flag[j] && turn == j);//轮到对方且对方想进入就等待
critical section;// 访问临界区
flag[i] = false;
remainder section;// 剩余区
 
Pj:
flag[j] = true; turn = i;
while (flag[i] && turn == i);
critical sectionl// 访问临界区
flag[j] = false;
remainder section;// 剩余区
```
### 硬件方法
#### 中断屏蔽方法
- **原理**：利用“开/关中断指令”实现互斥。
- **优点**：简单且高效。
- **缺点**：只适用于操作系统内核进程，不适用于多处理机和用户进程。
#### TestAndSet
- **原理**：整个操作不允许中断，确保“上锁”与“检查”由硬件控制。
- **优点**：适用于多处理机环境，在逻辑上更安全。
- **问题**：不满足“让权等待”。
```C
//布尔型共享变量 lock 表示当前临界区是否被加锁
//true 表示已加锁，false 表示未加锁
bool TestAndset(bool *lock){
	bool old;
	old =*lock;//old用来存放lock 原来的值
	*lock =true;//无论之前是否已加锁，都将lock设为true
	return old;
}
//调用
while(TestAndset(&lock));//lock原来的值为false才退出循环
```
#### Swap指令
- **原理**：通过交换指令实现互斥。
- **问题**：不满足“让权等待”。
```C
//lock 表示当前临界区是否被加锁  
bool old = true;  
while(old == true){ 
//如果lock是true，卡在while循环
	Swap(&lock,&old);  
}
临界区代码段。  
lock = false;  
剩余区代码段.
```
## 3.锁
### 互斥锁
**定义**：进程进入临界区前需获得锁，退出时释放。使用 `acquire()` 获得锁，`release()` 释放锁。
### 自旋锁
- **特点**：忙等的互斥锁，采用 TSL、Swap 指令或单标志法实现。
- **优点**：无需上下文切换，适合多处理器且锁持有时间短的场景。
- **缺点**：忙等浪费 CPU 时间，不适合单处理机，且可能违反“让权等待”。
## 4.信号量
**整型信号量**（int）
- 使用整数变量表示资源数量。
- **问题**：不满足“让权等待”，会发生忙等。
**记录型信号量**
相比int信号量多了：
- 小于0时block进程
- 大于0时唤醒进程
## 5.条件变量
用于线程间的通信，通常与互斥锁一起使用，以避免忙等问题。条件变量本身不是锁，但可以使线程阻塞，等待另一个线程发送信号。
## 6.经典同步问题
信号量定义写法：==semaphore mutex = 0;==
### 生产者-消费者问题
- `empty`：表示空余空间的信号量，缓冲区未满时大于0。
- `full`：表示已有产品的信号量，缓冲区不为空时大于0。
- `mutex`：互斥锁，确保缓冲区在访问时的互斥性。
```C
empty = BUFFER_SIZE;  // 缓冲区初始为空
full = 0;             // 缓冲区初始没有产品
mutex = 1;            // 互斥锁初始化为可用
// 生产者线程
void *producer(void *arg) {
    while (1) {
        // 生产产品
        P(empty);  // 等待空余空间
        P(mutex);  // 加锁，进入临界区
        // 放入产品到缓冲区
        V(mutex);  // 解锁，退出临界区
        V(full);   // 增加已有产品的数量
    }
}
// 消费者线程
void *consumer(void *arg) {
    while (1) {
        P(full);   // 等待缓冲区有产品
        P(mutex);  // 加锁，进入临界区
        // 从缓冲区取出产品
        V(mutex);  // 解锁，退出临界区
        V(empty);  // 增加空余空间的数量
    }
}
```
### 读者-写者问题
- **读者**：可以同时读取数据，但不能与写者同时操作。
- **写者**：在写操作进行时，其他任何读者和写者都不能访问数据。
#### 读优先
```C
mutex = 1;        // 互斥锁，保证互斥访问count
count = 0;    // 当前正在读的读者数
rw = 1;     // 读锁，控制读者间同步
// 读者线程
void *reader(void *arg) {
    while(1){
	    P(mutex);
	    if(count==0)P(rw); //第一个读者负责加锁
	    count++;
	    V(mutex);
	    // 读文件；
	    P(mutex);
	    count--;
	    if(count==0)V(rw); //最后一个读者负责解锁
	    V(mutex);
    }
}
// 写者线程
void *writer(void *arg) {
    P(rw);   // 写者等待，直到没有读者或其他写者
    // 执行写操作
    V(rw);   // 写完后释放写锁
}
```
#### 写优先
```C
mutex = 1;        // 互斥锁，保证互斥访问count
count = 0;    // 当前正在读的读者数
rw = 1;     // 读锁，控制读者间同步
w = 1;    //实现写优先
// 读者线程
void *reader(void *arg) {
    while(1){
	    P(w);    //有写进程的时候，新的读进程会被卡在这
	    P(mutex);
	    if(count==0)P(rw); //第一个读者负责加锁
	    count++;
	    V(mutex);
	    V(w);
	    // 读文件；
	    P(mutex);
	    count--;
	    if(count==0)V(rw); //最后一个读者负责解锁
	    V(mutex);
    }
}
// 写者线程
void *writer(void *arg) {
    P(w);
    P(rw);   // 写者等待，直到没有读者或其他写者
    // 执行写操作
    V(rw);   // 写完后释放写锁
    V(w);
}
```
### 哲学家进餐问题
假设有5个哲学家围坐在圆桌旁，桌上有5根筷子
解决办法：
1. **限制最大同时进餐的哲学家数量**：最多允许4个哲学家同时进餐，确保至少一个哲学家可以同时拿到左右两只筷子。
2. **奇偶哲学家先后拿筷子**：奇数号哲学家先拿左边筷子，再拿右边；偶数号哲学家先拿右边筷子
```C
mutex = 1;           // 互斥锁，用于控制哲学家的访问
chopstick[5] = {1, 1, 1, 1, 1}; // 表示筷子的信号量，1表示可用，0表示被占用
// 哲学家线程
void *philosopher(void *arg) {
    int i = *((int*)arg); // 哲学家的编号
    while (1) {
        think();
        P(mutex); // 加锁，防止多个哲学家同时拿筷子
        if (i % 2 == 0) {
            // 偶数号哲学家：先拿右边筷子，再拿左边筷子
            P(chopstick[(i + 1) % 5]); // 拿右边筷子
            P(chopstick[i]);            // 拿左边筷子
        } else {
            // 奇数号哲学家：先拿左边筷子，再拿右边筷子
            P(chopstick[i]);            // 拿左边筷子
            P(chopstick[(i + 1) % 5]); // 拿右边筷子
        }
        V(mutex); // 解锁
        eat();
        V(chopstick[i]);            // 放下左边筷子
        V(chopstick[(i + 1) % 5]); // 放下右边筷子
    }
}
```
# 死锁
## 1.死锁的基本概念
等待的资源在另一个进程手里
### 不死锁需要的资源
- 系统内有n个进程，每个进程都需要R个资源，那么其能发生死锁的最大资源数为n*（R-1）。其无论如何不发生死锁的最小资源数为n*（R-1）+1。
### 死锁的四个必要条件：
1. **互斥条件**：
    - 即每个资源在任意时刻只能被一个进程占用。
2. **不剥夺条件**：
    - 一旦进程获得了某个资源，系统不会强行剥夺该资源，进程必须自己释放。
3. **请求和保持条件**：
    - 进程已经持有至少一个资源，但又请求其他已经被占用的资源，并且在得到所请求的资源之前不会释放当前的资源。
4. **循环等待条件**：
    - 存在一个进程等待链，链中的每个进程都持有着下一个进程所需要的资源。
## 2.死锁预防
破坏四个必要条件之一
1. **破坏互斥条件**：
    - **方法**：将只能互斥的资源改为共享资源，如使用 SPOOLing 技术（共享打印机）。
    - **局限性**：并非所有资源都能改为共享，某些资源（如内存、文件锁）必须保持互斥。
2. **破坏不剥夺条件**：
    - **方法**：当进程无法获得资源时，立即释放已持有的资源。
    - **局限性**：可能导致饥饿（长期得不到资源），并需要考虑进程的优先级。
3. **破坏请求和保持条件**：
    - **方法**：采用静态分配策略，进程在启动前一次性申请所有所需资源。
    - **局限性**：资源利用率低，且可能导致进程饥饿。
4. **破坏循环等待条件**：
    - **方法**：使用顺序资源分配法，规定进程必须按资源编号递增顺序请求资源。
    - **局限性**：增加设备时需要重新编号，可能导致资源浪费，且不方便编程和资源申请。
## 3.死锁避免
1. **安全状态与安全序列**：
    - 系统处于安全状态时，存在至少一个进程执行的顺序（安全序列），所有进程都能顺利完成。
    - 如果找不到安全序列，系统进入不安全状态，可能发生死锁。
2. **银行家算法**：
    - 在进程请求资源时，预判此次分配是否会导致不安全状态。
    - 如果会导致不安全，系统暂不分配资源，进程进入等待状态，直到资源分配不会引发死锁。
## 4.死锁检测和解除
1. **死锁检测**：
    - **资源分配图**：包括进程节点和资源节点，边表示进程的资源请求和分配。
		- 进程结点（圆圈）:对应一个进程
		- 资源结点（矩形）:对应一类资源，一类资源可能有多个
		- 矩形中的圆点，一个圆点代表一个资源
    - **检测算法**：通过查找不阻塞且非孤立的进程，逐步消去资源分配图中的进程和边，若能完全简化图，系统是安全的，否则为死锁状态。
2. **死锁解除**：
    - **资源剥夺法**：挂起死锁进程并抢占其资源。
    - **撤销进程法**：强制撤销部分或全部死锁进程，代价高。
    - **进程回退法**：让死锁进程回退到安全状态，需要记录历史状态。
![[考研/操作系统/pic/Pasted image 20241210162501.png]]