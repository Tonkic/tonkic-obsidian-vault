---
tags:
  - 计算机组成原理
---
# 指令系统的基本概念
指令集体系结构（ISA）
- 规定计算机指令格式/操作数格式/寄存器权限/控制方式（PC）
# 指令格式
- 操作码+地址码
- 定长/变长，零/一/二地址指令
# 寻址方式
## 指令寻址
PC给出下一条指令的地址
## 数据寻址
### 直接寻址
指令字中的形式地址就是操作数的真实地址EA
### 间接寻址
#### 一次间址
形式地址中存储 真实地址所在的存储单元的地址，也就是操作数地址的地址。
#### 两次简址
### 寄存器寻址
形式地址 中给出操作数所在的寄存器编号。
#### 寄存器间接寻址
寄存器中给出操作数所在的主存单元的地址。EA=(Ri)
### 隐含寻址
指令中隐含这操作数的地址
举例：加法运算，形式地址中有一个操作数的地址。另一个操作数在 ACC寄存器中。
### 立即寻址
形式地址中存储操作数本身，又称立即数。一般采用补码表示。
### 基址寻址
将CPU中基址寄存器/BR 的内容加上指令格式中的形式地址A
基址寄存器是面向操作系统的，内容有操作系统或管理程序确定。
形式地址可正可负，使用补码存储，相加时需要转换成真值进行加减
### 变址寻址
形式地址A与变址寄存器IX的内容相加之和
变址寄存面向用户，用户可以改变
适合处理循环
### 基址寻址与变址寻址的区别
基址寻址实现程序的动态再定位
- 比如基址是0，我执行完一个在100的程序要切换到地址在200的程序，只需要跳转基址+200的地方就行
变址寻址实现程序内的地址变化
- 我在地址为100的程序中for循环访问数组，大小是5；
- 使用基址需要5条指令，形式地址分别是100.101.102.103.104；
- 但使用变址只需要执行同一条指令5次，每次执行完就将变址寄存器里的值+1；
	- 一开始变址100，形式地址0；
	- 最后变址104，形式地址0，形式地址一直不变。
### 相对寻址
程序计数器PC的内容（当前执行指令的地址+1）加上 形式地址A 而形成操作数的有效地址。即EA=(PC)+A。
A是相对于PC所指地址的位移量，可正科负，补码表示。
jmp等跳转指令的实现
### 堆栈寻址
操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址
# 数据的对齐和大/小端存放方式
## 数据的对齐
一般一次读内存读的是一个机器字长，64位计算机一次读取64bit
数据对齐可以防止读取数据的时候，一个数据被分割在两个字（32b）中，导致需要拼接才能读取到数据，多访存一次
![边界对齐](边界对齐.jpg)

### 具体存放规则
n字节的数据就需要在n的整数倍的字节开始存放
## 数据的高位是较大的部分
最高有效字节MSB
最低有效字节LSB
## 区分大小端
### 大端（从大到小，符合直觉）
MSB->LSB
### 小端（从小到大，反直觉）
LSB->MSB
# CISC 和 RISC的基本概念
## CISC复杂指令集
- 代表：X86架构(PC)
- 一条指令完成一个复杂的基本功能
## RISC精简指令集
- 代表：ARM架构(手机)
- 一条指令完成一个基本动作，多条指令组合完成一个复杂的基本功能。
- 只有load/store指令可以访存
# 高级语言程序与机器级代码之间的对应
## 1. 编译器、汇编器和链接器的基本概念
编译器：代码->汇编
汇编器：汇编->多个可重定位文件.o
链接器：多个可重定位文件.o->.exe
## 2. 选择结构语句的机器级表示
```x86asm
CMP x, 10     ; 比较x和10
JG  label_A   ; 如果x > 10，跳转到label_A
; 执行B(else语句块)
JMP  label_end ; 跳转到结束
label_A:
; 执行A（if符合的语句块）
label_end:
```
## 3. 循环结构语句的机器级表示
```x86asm
MOV i, 0          ; i = 0
loop_start:
CMP i, 10         ; 比较i与10
JGE loop_end      ; 如果i >= 10，跳出循环
; 执行循环体
INC i             ; i++
JMP loop_start    ; 跳回开始，继续下一次循环
loop_end:
```
## 4. 过程(函数)调用对应的机器级表示
```C
int add(int a, int b) {
    return a + b;
}
int caller() {
    int var1 = 125;
    int var2 = 80;
    int result;
    result = add(var1, var2);
    return result;
}
```
```asm
caller:
    push ebp                 ; push指令先让esp+4，然后把调用者的ebp保存到esp中
    mov ebp, esp             ; 将调用者栈顶作为自己的栈底
    sub esp, 24              ; 栈是向低地址增长，-24就是分配6个栈空间给caller函数（以4字节为单位）
    mov [ebp-12], 125        ; 将125存储到[ebp-12] (var1)
    mov [ebp-8], 80          ; 将80存储到[ebp-8] (var2)
    mov eax, [ebp-8]         ; 将var2 (80)加载到eax
    mov [esp+4], eax         ; 将eax的值（80）存储到栈的[esp+4]（add函数参数a）
    mov eax, [ebp-12]        ; 将var1 (125)加载到eax
    mov esp, eax             ; 设置esp为var1的值（120）
    call add                 ; 调用add函数，栈上参数为80和125
（call指令会将调用者的PC值压栈，并将被调用者地址存入PC）
    mov [ebp-4], eax         ; 将add函数的返回值存储到[ebp-4] (result)
    mov esp, ebp             ; 栈顶指针指向栈底
    pop ebp                  ; pop指令先让esp-4，然后把栈中存储的调用者的ebp赋给ebp
    ret                      ; 返回
（ret指令会读取栈顶esp写回PC寄存器）
add:
    push ebp                 ; push指令先让esp+4，然后把调用者的ebp保存到esp中
    mov ebp, esp             ; 将调用者栈顶作为自己的栈底
    mov eax, [ebp+12]        ; 获取第一个参数a
    mov edx, [ebp+8]         ; 获取第二个参数b
    add eax, edx             ; 将eax和edx相加，结果存储在eax
    mov esp, ebp             ; 栈顶指针指向栈底
    pop ebp                  ; pop指令先让esp-4，然后把栈中存储的调用者的ebp赋给ebp
    ret                      ; 返回
```

| ![[Pasted image 20241208161649.png\|200]] | ![[Pasted image 20241208162936.png\|180]] |
| ----------------------------------------------- | ----------------------------------------------- |
sum就是调用者ebp-4，temp2是ebp-8，x是被调用者的ebp+8
mov指令不支持两个操作数都来自内存，所以需要eax中转
### 寄存器
EBP指向栈底
ESP指向栈顶