---
tags:
  - 数据结构
---
# 概念
多重图：有重复/指向自己的边
路径：不出现重复的顶点
连通：无向图，任意两个结点有路径
强连通：有向图，每个结点都有路径到图中剩余的所有结点
连通分量：无向图，最大连通子图
强连通分量：有向图，最大强连通子图
完全图：任意两个结点都有双向的边
# 存储
## 邻接矩阵(顺序存储)
邻接矩阵的n次方表示顶点i和顶点j之间是否有长度为n的路径，有则为0		
$$\begin{matrix}{}
A =  {\begin{matrix}{}
0&1&0&1\\
1&0&1&0\\
0&1&0&1\\
1&0&1&0
\end{matrix}} \\
{A^2} = {\begin{matrix}{}
2&0&2&0\\
0&2&0&2\\
2&0&2&0\\
0&2&0&2
\end{matrix}}
\end{matrix}$$
## 邻接表(顺序+链式)
找入度的弧不方便,需要遍历全部指针
## 十字链表/存储有向图
每条弧用一个数据结构存储，可以找到弧头相同的下一条弧/弧尾相同的下一条弧；每个顶点存该顶点作为弧头的第一条弧和该顶点作为弧尾的第一条弧
## 邻接多重表/存储无向图
如果使用 邻接矩阵或邻接表存储，每一条边都存在两份相同的数据。
邻接多重表存边，存边的两头ij和依附于顶点i的下一条边依附于顶点j的下一条边
# 遍历
## BFS
## DFS
## 可以用来求连通分量数
每个连通分量只需要调用一次DFS或BFS，因此调用次数等于连通分量的数量。
# 应用
## 最小代价生成树
### Prim/普里姆 算法
从某一个顶点开始构建生成树；
每次将代价最小的新顶点纳入生成树，知道所有顶点都纳入为止
时间复杂度O(|V|^2)适用于边稠密图
### Kruskal/克鲁斯卡尔 算法
每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的就不选)；直到所有结点都连通
时间复杂度O( |E| log以2为底的 |E| )适用于边稀疏图
## 最短路径问题
#### 单源最短路径
##### BFS算法(无权图)
广度优先遍历去计算最短路径
##### Dijkstra/地杰斯特拉 算法
###### 算法内容
三个数组
final检查结点是否已经找到最短路径
dist表示源结点到目标结点的最短路径
path表示路径的前驱
###### 时间复杂度
On^2 即 OV^2;
不能使用于有负权值的带权图
#### 每对顶点间的最短路径
##### Floyd/弗洛伊德 算法
###### 复杂度
时间复杂度 O v^3;
空间复杂度 O v^2;
###### 不能解决的问题
带有负权回路的图
###### 步骤
遍历矩阵，第一次运行使用v0中转，遍历9个元素，v0-v0-v0，v0-v0-v1... ...v2-v0-v1，v2-v0-v2
下一趟遍历允许使用v1中转
## 表达式问题
使用有向无环图表示表达式
操作数放在最底下，按顺序一层一层向上叠操作符
## 拓扑排序
- 从 AOV 网中选择一个没有前驱 (入度为0) 的顶点并输出
- 从网中删除该顶点和所有以它为起点的有向边
- 重复 1、2 直到当前 AOV 网为空
- 可以判断是否有回路
## 关键路径
事件是点活动是边
求所有事件的最早发生时间 ve()求MAX
求所有事件的最迟发生时间 vI()求MIN
求所有活动的最早发生时间 e()=边的起点的ve
求所有活动的最迟发生时间 I()=边的终点的vl-边的持续时间
求所有活动的时间余量 d()=l-e
d=0的就是关键路径