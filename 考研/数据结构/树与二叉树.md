---
tags:
  - 数据结构
---
# 二叉树
## 存储
### 顺序存储
左结点是2n，右结点是2n+1
### 链式存储
一个结点两个node*，n个结点的二叉链表共有n+1个空链域
## 性质
1. 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1
## 遍历
### 先序遍历
中左右
#### 使用栈实现
出栈输出值，同时右结点进栈，然后左结点进栈
```C
while (!stack.isEmpty()) {
	TreeNode node = stack.pop();
	ans.add(node.val);
	if (node.right != null) {
		stack.push(node.right);
	}
	if (node.left != null) {
		stack.push(node.left);
	}
}
```
### 中序遍历
左中右
#### 使用栈实现
先一直往左遍历并入栈，如果遍历到空就出栈输出结点，然后转到右结点进行下一个循环（一直遍历左结点）
```c
TreeNode cur = root; 
while (!stack.isEmpty() || cur != null) { 
	if (cur != null) { 
		stack.push(cur); cur = cur.left; } 
	else { 
		TreeNode node = stack.pop(); 
		ans.add(node.val); 
		cur = node.right; }
} 
```
### 先序遍历
左右中
#### 使用栈实现
1. 使用两个栈：一个栈用于存储节点，另一个栈用于存储访问的顺序。
2. 然后，处理当前节点的右子节点和左子节点，按照右子节点先入栈的顺序。
3. 最终，当栈为空时，从第二个栈中取出元素，得到后续遍历的结果。
```C
TreeNode cur = root;
stack.push(cur);
while (!stack.isEmpty()) {
	TreeNode node = stack.pop();
	// 先存一个栈里面
	helper.push(node);
	// 先序遍历的时候，是先判断右树，改造一下，先判断左树
	if (node.left != null) {
		cur = node.left;
		stack.push(cur);
	}
	if (node.right != null) {
		cur = node.right;
		stack.push(cur);
	}
}
while (!helper.isEmpty()) {
	ans.add(helper.pop().val);
}
```
## 线索二叉树
#### 使用tag标记位判断左右孩子是真的左右孩子还是前驱后继
tag为1时是线索，tag为0是孩子
#### 找前驱后继
中序
	前驱
		tag=0时找左节点的最右下孩子直到tag=1
	后继
		tag=0时找右节点的最左下孩子直到tag=1
先序
	前驱
		找不到！！！
		不在左右子树中，找到父节点才能找到
	后继
		找左孩子
		没左孩子找右孩子
后序
	前驱
		找右孩子
		没右孩子找左孩子
	后继
		找不到！！！
		不在左右子树中，找到父节点才能找到
# 树
## 存储
双亲表示法：数组存所以结点与其对应的双亲（并查集）
孩子表示法：类似邻接链表
孩子兄弟表示法：转为二叉树存储，存长子+兄弟
## 遍历
| 森林  | 树   | 二叉树 |
| --- | --- | --- |
| 先序  | 先序  | 先序  |
| 中序  | 后序  | 中序  |
## 互相转换
左长子右兄弟
# 树与二叉树的应用
## 哈夫曼树和哈夫曼编码
### 带权路径长度
#### 结点的带权路径长度
从树的根节点 到 该结点的路径程度(经过的边数)与该结点上权值的乘积
#### 树的带权路径长度
树的所有结点的带权路径长度之和
# 堆及其应用
## 建堆
### 上滤建堆
一个一个插入到最后，然后不断上移直到符合堆，复杂度nlogn
### 自下向上
从第n/2个元素开始检查是否符合大/小根堆的性质，不符合则调整（如果左/右节点进行了调整，还要继续检查左/右是否符合堆性质），从第n/2个检查到第一个
## 应用
### 优先队列
使用小根堆维护优先队列，实现输出一个队列的最小值
### 动态中位数
一个大根堆一个小根堆得到中位数
### 快速找到第K大的或第K小的元素
维护一个大小为K的堆