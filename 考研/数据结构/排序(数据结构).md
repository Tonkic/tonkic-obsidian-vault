---
tags:
  - 数据结构
---
# 插入排序
## 直接插入排序
插入到前面已经排好序的子序列中
## 折半插入排序
与前边已经排序号的序列比较时，使用折半查找，比较关键字的次数减少了
## 希尔排序
使用增量d划分为子表，然后不断减小d
# 交换排序
## 冒泡排序
两两比较时，元素相同，不做处理，以保证算法稳定性
若某一趟排序没有发生 交换 说明此时已经整体有序。算法可提前结束，所以比较次数与初始序列有关
## 快速排序
在待排序表中任取一个元素 pivot 作为枢轴/基准，通常取首元素
通过一趟排序将待排序表划分为独立的两部分，使得左部分元素都小于 pivot，有部分元素都大于pivot，则 pivot 放在了其最终位置，这个过程称为一次 划分
分别递归的对两个字表重复上述过程。
# 选择排序
定义
每一趟在待排序元素中，选取关键字最小(或最大)的元素加入有序子序列
分类
## 简单选择排序
每一趟在待排序元素中选取关键字最小的元素加入有序子序列
有两个最小的，取左边的，不稳定
## 堆排序
### 建立堆
#### 由初始序列建立大根堆
[[树与二叉树#自下向上]]
### 基于大根堆进行排序
假设大根堆大小为n
1. 将大根堆的堆顶元素（最大的）与待排序序列中的最后一个元素交换
2. 对剩下的n-1个元素重新调整为大根堆
### 堆插入
元素插在表尾
与父节点比较，不满足堆的要求，就上升，交换父节点和当前结点
### 堆删除
使用堆尾元素替代
然后下坠，只需要对比换上来的堆底元素，使其下坠即可
# 归并排序和基数排序
## 归并排序 Merge Sort
把两个或多个 已经有序的 序列合并成一个
### 最佳归并树
带权的归并需要构造哈夫曼树
#### n路归并的情况
每次选择权值最小（读写次数/磁盘块数最少）的两颗子树，构成新树
#### n路归并的情况
与二路归并相似，每次选择n个权值最小的结点
##### 补充虚段的数量
若初始数量，无法构成严格的K叉归并树（只包含度为k和度为0的结点），应该初始补长度为 0 的 虚段，再进行构造哈夫曼树
$$\left\{
\begin{array}{c}
    n=n_0+n_k \\
    n_k\cdot k = n-1 \\
\end{array}
\right.$$
得到$$n_k=\frac{n_0-1}{k-1}$$
## 基数排序 Radix Sort
顺序：个十百/日月年
# 不稳定/与初始无关
- 不稳定：希儿快速选择堆
- 与初始无关：快速选择归并基数(快选龟基)
# 外部排序
## [[排序(数据结构)#最佳归并树]]
## 败者树
可视为一棵完全二叉树，多了一个头头。
k个叶结点分别是当前参加比较的元素，非叶子结点用来记忆 左右子树中的 “失败者” ，而让胜者往上继续进行比较，一直到根节点
## 置换选择排序
通过有限的缓冲区构建不等长的初始归并段
比如缓冲区大小为3，构建时使用MINIMAX当前归并段的最大值
- 4 9 6 5 2，MINIMAX先4后9然后缓冲区652都比MINIMAX小，只能新建归并段，得到一个归并段4，9 