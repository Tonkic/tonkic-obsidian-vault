---
tags:
  - 数据结构
---
# 查找的基本概念
查找长度
	查找运算中，需要对比关键字的次数
平均查找长度 ASL Average Search Length
	所有查找过程中进行关键字比较次数的平均值
# 顺序查找法
从头到尾挨个找
# 分块查找法
“索引表”中保存每个分块的最大关键字和分块的存储区间
块内无序，块间有序
# 折半查找法
```C
typedef struct {
    ElemType *elem;   // 动态数组基址
    int TableLen;     // 表的长度
} ssTable;
// 折半查找
int Binary_Search(ssTable L, ElemType key) {
    int low = 0, high = L.TableLen - 1, mid;

    while (low <= high) {
        mid = (low + high) / 2;

        if (L.elem[mid] == key) {
            return mid; // 找到目标元素，返回索引
        } else if (L.elem[mid] > key) {
            high = mid - 1; // 目标元素在前半部分
        } else {
            low = mid + 1; // 目标元素在后半部分
        }
    }

    return -1; // 查找失败，返回-1
}
```
# 树形查找
## 二叉搜索树
左子树结点值 < 根结点值 < 右子树结点值
中序遍历，可以得到一个递增的有序序列
删除时，只有一颗子树就用子树顶替，两颗子树就用前继/后继顶替
## 平衡二叉树
结点的平衡因子=左子树高 - 右子树高
### 调整最小不平衡子树
找最小不平衡子树根结点（平衡因子为2/-2），然后LL第一个L表示根结点的左孩子，第二个L表示根结点的左孙子
#### LL 在左子树的左孩子处插入新结点
第一个L右旋
#### RR 在右子树的右孩子处插入新结点
第一个R左旋
#### LR 在左子树的右孩子处插入新结点（根LR）
R先左旋代替L，L再右旋代替根
#### RL 在右子树的左孩子处插入新结点（根RL）
L先右旋顶替R，R在左旋顶替根
### 平衡二叉树的删除
树中结点通过前驱后继转换为删除叶结点
一路向北（叶向根遍历）找不平衡然后调整
调整后可能导致新的不平衡向上传递，只需继续一路向北
## 红黑树
### 性质
- 左右子树高度差，不超过2倍
- 左根右、根叶黑、不红红、黑路同
### 插入
先查找，确定插入位置(原理同二叉排序树)，插入新结点
新结点是根
- 染为黑色
新结点非根
- 染为红色
若插入新结点后依然满足红黑树定义，则插入结束
若插入新结点后不满足红黑树定义，需要调整，使其重新满足红黑树定义
`黑叔:旋转+染色`（没叔叔默认黑叔）
LL型:右单旋，交换的结点是父爷，父爷换色
RR型:左单旋，交换的结点是父爷，父爷换色
LR型:左、右双旋，交换的结点是子爷，子爷换色
RL型:右、左双旋，交换的结点是子爷，子爷换色
`红叔:染色+变新`
叔父爷染色，爷变为新结点
## B树
### 如何保证查找效率
- 处理根节点外，任何结点至少有 $\lceil \frac{m}{2} \rceil$ 个分叉，即至少含有 $\lceil \frac{m}{2} \rceil - 1$ 个关键字。
- 对于任何一个结点，其所有子树的高度都要相同
### 定义
- 根节点的子树数量，最少为2
- 除根节点至少有m/2个分支，至少含有m/2-1个关键值（m/2向上取整）
### 高度
$$\log_{\lceil m \rceil}(n+1) \leq h \leq \log_{\lceil m/2 \rceil}\left(\frac{n+1}{2}\right) + 1$$
### B树的插入删除
#### 插入
- 若导致原结点关键字数超过上线，从中间位置将关键字分为两部分。中间位置 $\lceil \frac{m}{2} \rceil$ 作为原结点的父节点
- 新元素插入到终端结点、用查找确定位置
#### 删除
- 若删除关键字在非终端结点，用直接前驱或直接后继 替代被删除元素
- 删除后，关键字数目小于$\lceil \frac{m}{2} \rceil-1$。
	- 借兄弟的
	- 兄弟内元素、借出后小于$\lceil \frac{m}{2} \rceil-1$，合并当前和兄弟
## B+树
### 定义
只有叶子结点存数据，非叶子结点存其所有子结点的最大值
### 性质
- 在B+树中，非叶结点不存储该关键字对应记录的存储地址。此结点所占空间更小。一个磁盘块可存储更多结点。读磁盘次数更少，查找更快
- 叶结点支持顺序查找
# 散列表
## 处理冲突的方法
### 通过拉链法/链接法/链地址法处理冲突
### 开放定址法（发生冲突时可以存到非同义词表项）
#### 线性探测法
- 发生冲突时，每次向后探测相邻的下一个单元是否为空
- `删除时，为逻辑删除。`用一个tag逻辑删除，表示这个数可以被替换，计算查找失败的查找长度时需要算上
#### 平方探测法
- 散列表长度m必须是一个可以表示成 4j+3 的素数，才能探测到所有位置
#### 伪随机序列法
### 再散列法
- 准备多个散列函数，发生冲突，用下一个散列函数计算新地址
## 概念
- 平均查找长度 ASL
	- 分成功情况失败情况    
- 装填因子α = 表中记录数/散列表长度
# 字符串模式匹配
## KMPnext数组
不算当前，前面的最长公共前后缀
## 失配时
直接向右移动next数组的值个位置